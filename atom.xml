<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>llllz_liu</title>
  
  <subtitle>llllzの博客</subtitle>
  <link href="https://gitee.com/yunyd/atom.xml" rel="self"/>
  
  <link href="https://gitee.com/yunyd/"/>
  <updated>2023-08-12T06:49:44.201Z</updated>
  <id>https://gitee.com/yunyd/</id>
  
  <author>
    <name>llllz.</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OPEN-API开放平台</title>
    <link href="https://gitee.com/yunyd/posts/574f1a5b.html"/>
    <id>https://gitee.com/yunyd/posts/574f1a5b.html</id>
    <published>2023-08-07T05:12:22.000Z</published>
    <updated>2023-08-12T06:49:44.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OPEN-API开放平台"><a href="#OPEN-API开放平台" class="headerlink" title="OPEN-API开放平台"></a>OPEN-API开放平台</h1><h2 id="项目所用到的技术："><a href="#项目所用到的技术：" class="headerlink" title="项目所用到的技术："></a>项目所用到的技术：</h2><ul><li>Java Spring Boot</li><li>MySQL 数据库</li><li>MyBatis-Plus 及 MyBatis X 自动生成</li><li>Swagger + Knife4j 接口文档生成</li><li>API 签名认证（Http 调用）</li><li>Spring Boot Starter（SDK 开发）</li><li>Dubbo 分布式（RPC、Nacos）</li><li>Spring Cloud Gateway 微服务网关</li><li>Hutool、Apache Common Utils、Gson 等工具库</li></ul><h2 id="后端："><a href="#后端：" class="headerlink" title="后端："></a>后端：</h2><ol><li> 根据业务流程，将整个项目后端划分为 web 系统、模拟接口、公共模块、客户端 SDK、API 网关这 5 个子项目，并使用 Maven 进行多模块依赖管理和打包。</li><li> 基于 MyBatis Plus 框架的 QueryWrapper 实现对 MySQL 数据库的灵活查询，并配合 MyBatis X 插件自动生成后端 CRUD 基础代码，减少重复工作。</li><li> 使用 Swagger + Knife4j 自动生成 OpenAPI 规范的接口文档，降低前后端协作成本。</li><li> 为防止接口被恶意调用，设计 API 签名认证算法，为用户分配唯一 ak / sk 以鉴权，保障调用的安全性、便于统计接口调用次数。</li><li> 为解决开发者调用成本过高的问题（须自己使用 HTTP + 封装签名去调用接口），基于 Spring Boot Starter 开发了客户端 SDK，一行代码 即可调用接口，提高开发体验。</li><li> 选用 Spring Cloud Gateway 作为 API 网关，实现了路由转发、访问控制、流量染色，并集中处理签名校验、请求参数校验、接口调用统计等业务逻辑，提高安全性的同时、便于系统开发维护。</li><li> 为解决多个子系统内代码大量重复的问题，抽象模型层和业务层代码为公共模块，并使用 Dubbo RPC 框架实现子系统间的高性能接口调用，大幅减少重复代码。</li></ol><h2 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h2><p>一个提供API接口供开发者调用的平台</p><p>管理员可以接入并发布接口，统计分析个接口调用情况；用户可以注册登录并开通接口调用权限，然后可以浏览接口及在线调试，还能使用客户端SDK轻松在代码中调用接口。</p><h3 id="项目功能及各部分页面介绍，如下图："><a href="#项目功能及各部分页面介绍，如下图：" class="headerlink" title="项目功能及各部分页面介绍，如下图："></a>项目功能及各部分页面介绍，如下图：</h3><h4 id="登陆界面："><a href="#登陆界面：" class="headerlink" title="登陆界面："></a>登陆界面：</h4><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/api/%E7%99%BB%E9%99%86%E7%95%8C%E9%9D%A2.jpg"></p><h4 id="主页浏览（管理员身份）："><a href="#主页浏览（管理员身份）：" class="headerlink" title="主页浏览（管理员身份）："></a>主页浏览（管理员身份）：</h4><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/api/%E4%B8%BB%E9%A1%B5%E6%B5%8F%E8%A7%88%EF%BC%88%E7%AE%A1%E7%90%86%E5%91%98%E8%BA%AB%E4%BB%BD%EF%BC%89.jpg"></p><h4 id="接口管理（管理员身份）："><a href="#接口管理（管理员身份）：" class="headerlink" title="接口管理（管理员身份）："></a>接口管理（管理员身份）：</h4><p>管理员身份具有管理页等选项框，用于接口管理和接口分析这两个功能，</p><p>接口管理用来发布、下线接口，对接口信息的增删改查等等功能</p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/api/1.jpg"></p><p>点击修改，弹出此接口信息的信息框用来进行修改操作</p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/api/2.jpg"></p><h4 id="接口分析（管理员身份）："><a href="#接口分析（管理员身份）：" class="headerlink" title="接口分析（管理员身份）："></a>接口分析（管理员身份）：</h4><p>用于调查接口里面的<u>top3</u>（接口调用次数最多的前三名接口名称及其调用次数），方便管理员进行接口分析和管理</p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/api/3.jpg"></p><h4 id="在线调试："><a href="#在线调试：" class="headerlink" title="在线调试："></a>在线调试：</h4><p>按照要求输入，即可调用已经发布上线的接口，并使用其功能</p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/api/4.jpg"></p><p>此处是一个功能简单的接口，在请求参数按照规范来输入，点击调用，即可调用该接口的功能。该接口的功能是：输入一个名字，即可返回调用的类型 + 用户输入的名字，调用成功后会弹出调用成功的框，并在下面返回结果出得到返回结果。</p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/api/5.jpg"></p><h4 id="主页浏览（非管理员身份）"><a href="#主页浏览（非管理员身份）" class="headerlink" title="主页浏览（非管理员身份）:"></a>主页浏览（非管理员身份）:</h4><p>仅可以在线调用接口，不能对接口进行权限处理等功能</p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/api/%E4%B8%BB%E9%A1%B5%E6%B5%8F%E8%A7%88%EF%BC%88%E9%9D%9E%E7%AE%A1%E7%90%86%E5%91%98%E8%BA%AB%E4%BB%BD%EF%BC%89.jpg"></p><h4 id="多个后端："><a href="#多个后端：" class="headerlink" title="多个后端："></a>多个后端：</h4><p>开放平台项目涉及到了<u>多个系统</u>的交互（不止有一个后端），包括了API签名认证、网关、RPC、分布式等知识</p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/api/6.jpg"></p><h4 id="（以上项目大体功能等仅粗略展示，如功能解释的不详细，还望见谅！！）"><a href="#（以上项目大体功能等仅粗略展示，如功能解释的不详细，还望见谅！！）" class="headerlink" title="（以上项目大体功能等仅粗略展示，如功能解释的不详细，还望见谅！！）"></a>（以上项目大体功能等仅粗略展示，如功能解释的不详细，还望见谅！！）</h4><p>.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;OPEN-API开放平台&quot;&gt;&lt;a href=&quot;#OPEN-API开放平台&quot; class=&quot;headerlink&quot; title=&quot;OPEN-API开放平台&quot;&gt;&lt;/a&gt;OPEN-API开放平台&lt;/h1&gt;&lt;h2 id=&quot;项目所用到的技术：&quot;&gt;&lt;a href=&quot;#项目所用</summary>
      
    
    
    
    <category term="项目" scheme="https://gitee.com/yunyd/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="项目" scheme="https://gitee.com/yunyd/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>商家外卖</title>
    <link href="https://gitee.com/yunyd/posts/7161264.html"/>
    <id>https://gitee.com/yunyd/posts/7161264.html</id>
    <published>2023-08-07T05:12:22.000Z</published>
    <updated>2023-08-12T06:49:50.755Z</updated>
    
    <content type="html"><![CDATA[<h1 id="商家外卖"><a href="#商家外卖" class="headerlink" title="商家外卖"></a>商家外卖</h1><h2 id="项目所用到的技术："><a href="#项目所用到的技术：" class="headerlink" title="项目所用到的技术："></a>项目所用到的技术：</h2><ul><li>Spring Boot </li><li>SSM  + Lombok</li></ul><ul><li>MyBatis Plus </li><li> Spring Cache </li><li> Redis </li><li> Sharding JDBC 读写分离 </li></ul><h2 id="部署："><a href="#部署：" class="headerlink" title="部署："></a>部署：</h2><p>前后端不分离 jar 包部署</p><h2 id="后端："><a href="#后端：" class="headerlink" title="后端："></a>后端：</h2><ol><li>为集中处理系统异常，自定义统一的错误码，并封装了 <strong>全局异常处理器</strong> ，屏蔽了项目冗余的报错细节、便于接口调用方理解和统一处理。</li><li>基于静态 ThreadLocal 封装了线程隔离的全局上下文对象，便于在请求内部存取用户信息，减少用户远程查询次数。</li><li>为兼容请求参数 date 类型的序列化，自定义 Jackson 对象映射器处理日期；并扩展 SpringMVC 的消息转换器，实现自动序列化。</li><li>自定义 MyBatis Plus 的 MetaObjectHandler，配合全局上下文实现写数据前的创建时间、用户 id 字段的自动填充。</li><li>遵循 Restful 设计规范编写接口，降低前后端接口沟通和理解成本。</li><li>为解决原生 Jdk 序列化器导致的缓存 key 值乱码问题，自定义 RedisTemplate Bean 的 Redis Key 序列化器为 StringRedisSerializer。</li><li>使用 Knife4j + Swagger 自动生成后端接口文档，并通过编写 ApiOperation 等注解补充接口注释，避免了人工编写维护文档的麻烦。</li><li>为省去重复编写用户校验的麻烦，基于 WebFilter 实现全局登录校验；并通过 AntPathMatcher 来匹配动态请求路径，实现灵活的可选鉴权。</li><li>为保证数据的完整性和一致性，使用 @Transactional 实现数据库事务，并配置 rollbackFor = Exception.class 来支持受检异常的事务回滚。</li><li>为提高信息页加载速度，基于 Spring Cache 注解 + Redis 实现对信息的自动缓存，来降低数据库压力的同时将接口响应耗时</li><li>为降低开发成本，使用 MyBatis Plus 框架自动生成业务的增删改查重复代码，并使用 LambdaQueryWrapper 实现更灵活地自定义查询。</li><li>为提高数据库整体读写性能，配置 MySQL 主从同步，并使用 sharding-jdbc 实现业务无侵入的读写分离。</li><li>封装全局 Axios 请求实例，添加全局请求拦截和全局异常响应处理器，减少重复的状态码判断、提升项目可维护性。﻿</li></ol><h2 id="项目功能及各部分页面介绍，如下图："><a href="#项目功能及各部分页面介绍，如下图：" class="headerlink" title="项目功能及各部分页面介绍，如下图："></a>项目功能及各部分页面介绍，如下图：</h2><h3 id="项目分为用户端和管理端："><a href="#项目分为用户端和管理端：" class="headerlink" title="项目分为用户端和管理端："></a>项目分为用户端和管理端：</h3><h4 id="用户端介绍："><a href="#用户端介绍：" class="headerlink" title="用户端介绍："></a>用户端介绍：</h4><p>页面输入手机号，首先会对手机号码有一个校验，不符合规则的的手机号会进行提示。然后点击验证码会直接给出验证码，由于模拟真实的短信服务需要付费并调用XX云SDK接入短信服务，为了节省成本，我直接将返回的验证码写在输入框里（模拟一下接收短信的流程）</p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/reggie/1-tuya.jpg"></p><p>注册登录进来后就可以查看商家信息（都哪有些菜品，套餐之类的）</p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/reggie/9-tuya.jpg"></p><p>随机选择一个，点击选择规格，会弹出如下框，选择适合自己的口味并点击加入购物车</p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/reggie/10-tuya.jpg"></p><p>点击完加入购物车之后，即可在购物车中显示，如果同一菜品想要多份的话，就点击➕来增加份数，购物车显示的金额也会随之更新</p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/reggie/11-tuya.jpg"></p><p>点击去结算的按钮会到支付页面，当然如果是新注册的账号，则会先让你留下收货地址，如下图</p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/reggie/12-tuya.jpg"></p><p>保存完收货地址，就可以进行支付了</p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/reggie/13-tuya.jpg"></p><h4 id="管理端介绍："><a href="#管理端介绍：" class="headerlink" title="管理端介绍："></a>管理端介绍：</h4><p>管理端是用来商家来上传一些菜品，套餐之类的，并包括员工信息等，可以对员工信息、菜品、套餐等信息进行增删改查等功能</p><p>下图为管理端的登陆页面：</p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/reggie/2-tuya.jpg"></p><p>点击登录，来到管理端页面</p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/reggie/3-tuya.jpg"></p><p>分为左列几个功能，能对响应分类进行增上改查，拿员工管理界面的增上改查来举例子：</p><p>点击编辑，可以修改员工信息。点击添加员工可以进行添加，启用禁用功能是指如果员工加入企业或者退出企业，可以对他的账号进行封禁或者开启</p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/reggie/5-tuya.jpg"></p><p>点击修改，效果如下图：</p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/reggie/4-tuya.jpg"></p><p>其余界面如下，功能类似，都可以进行增删改查等功能：</p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/reggie/6-tuya.jpg"></p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/reggie/7-tuya.jpg"></p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/reggie/8-tuya.jpg"></p><h4 id="（以上项目大体功能等仅粗略展示，如功能解释的不详细，还望见谅！！）"><a href="#（以上项目大体功能等仅粗略展示，如功能解释的不详细，还望见谅！！）" class="headerlink" title="（以上项目大体功能等仅粗略展示，如功能解释的不详细，还望见谅！！）"></a>（以上项目大体功能等仅粗略展示，如功能解释的不详细，还望见谅！！）</h4><p>.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;商家外卖&quot;&gt;&lt;a href=&quot;#商家外卖&quot; class=&quot;headerlink&quot; title=&quot;商家外卖&quot;&gt;&lt;/a&gt;商家外卖&lt;/h1&gt;&lt;h2 id=&quot;项目所用到的技术：&quot;&gt;&lt;a href=&quot;#项目所用到的技术：&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="项目" scheme="https://gitee.com/yunyd/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="项目" scheme="https://gitee.com/yunyd/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>LockSupport与线程中断-4</title>
    <link href="https://gitee.com/yunyd/posts/b972fab5.html"/>
    <id>https://gitee.com/yunyd/posts/b972fab5.html</id>
    <published>2023-08-05T08:42:32.000Z</published>
    <updated>2023-08-13T11:57:03.771Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LockSupport与线程中断"><a href="#LockSupport与线程中断" class="headerlink" title="LockSupport与线程中断"></a>LockSupport与线程中断</h1><h2 id="4-1-线程中断机制"><a href="#4-1-线程中断机制" class="headerlink" title="4.1 线程中断机制"></a>4.1 线程中断机制</h2><h4 id="4-1-1-从阿里蚂蚁金服面试题讲起"><a href="#4-1-1-从阿里蚂蚁金服面试题讲起" class="headerlink" title="4.1.1 从阿里蚂蚁金服面试题讲起"></a>4.1.1 从阿里蚂蚁金服面试题讲起</h4><p>Java.lang.Thread下的三个方法:</p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/JUC/19.jpg"></p><ul><li>如何中断一个运行中的线程？</li><li>如何停止一个运行中的线程？</li></ul><h4 id="4-1-2-什么是中断机制"><a href="#4-1-2-什么是中断机制" class="headerlink" title="4.1.2 什么是中断机制"></a>4.1.2 什么是中断机制</h4><ul><li><p>首先，一个线程不应该由其他线程来强制中断或停止，而是应该由线程自己自行停止，自己来决定自己的命运，所以，Thread.stop,Thread.suspend,Thread.resume都已经被废弃了</p></li><li><p>其次，在Java中没有办法立即停止一条线程，然而停止线程却显得尤为重要，如取消一个耗时操作。因此，Java提供了一种用于停止线程的协商机制—-中断，也即中断标识协商机制</p></li><li><ul><li>中断只是一种协作协商机制，Java没有给中断增加任何语法，中断的过程完全需要程序员自行实现。若要中断一个线程，你需要手动调用该线程interrupt方法，该方法也仅仅是将该线程对象的中断标识设置为true，接着你需要自己写代码不断检测当前线程的标识位，如果为true，表示别的线程请求这条线程中断，此时究竟应该做什么需要你自己写代码实现。</li><li>每个线程对象都有一个中断标识位，用于表示线程是否被中断；该标识位为true表示中断，为false表示未中断；通过调用线程对象的interrupt方法将该线程的标识位设置为true；可以在别的线程中调用，也可以在自己的线程中调用。</li></ul></li></ul><h4 id="4-1-3-中断的相关API方法之三大方法说明"><a href="#4-1-3-中断的相关API方法之三大方法说明" class="headerlink" title="4.1.3 中断的相关API方法之三大方法说明"></a>4.1.3 中断的相关API方法之三大方法说明</h4><ul><li><p>public void interrupt()</p></li><li><ul><li>实例方法 Just to set the interrupt flag</li><li>实例方法仅仅是设置线程的中断状态为true，发起一个协商而不会立刻停止线程</li></ul></li><li><p>public static boolean interrupted()</p></li><li><ul><li>静态方法 Thread.interrupted();</li><li>判断线程是否被中断并清除当前中断状态（做了两件事情）</li></ul></li><li><ul><li><ul><li>1.返回当前线程的中断状态，测试当前线程是否已被中断</li><li>2.将当前线程的中断状态清零并重新设置为false，清除线程的中断状态</li><li>3.这个方法有点不好理解在于如果连续两次调用此方法，则第二次返回false，因为连续调用两次的结果可能不一样</li></ul></li></ul></li><li><p>public boolean isInterrupted()</p></li><li><ul><li>实例方法</li><li>判断当前线程是否被中断（通过检查中断标志位）</li></ul></li></ul><h4 id="4-1-4-大厂面试题中断机制考点"><a href="#4-1-4-大厂面试题中断机制考点" class="headerlink" title="4.1.4 大厂面试题中断机制考点"></a>4.1.4 大厂面试题中断机制考点</h4><ul><li><p>如何停止中断运行中的线程？</p></li><li><ul><li>通过一个volatile变量实现</li></ul></li></ul><p>volatile中断线程演示：</p><pre class="line-numbers language-none"><code class="language-none">public class InterruptDemo {    static volatile boolean isStop = false; //volatile表示的变量具有可见性    public static void main(String[] args) {        new Thread(() -&gt; {            while (true) {                if (isStop) {                    System.out.println(Thread.currentThread().getName() + " isStop的值被改为true，t1程序停止");                    break;                }                System.out.println("-----------hello volatile");            }        }, "t1").start();        try {            TimeUnit.MILLISECONDS.sleep(10);        } catch (InterruptedException e) {            e.printStackTrace();        }        new Thread(() -&gt; {            isStop = true;        }, "t2").start();    }}/** * -----------hello volatile * -----------hello volatile * -----------hello volatile * -----------hello volatile * -----------hello volatile * -----------hello volatile * t1 isStop的值被改为true，t1程序停止 */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><ul><li>通过AutomicBoolean</li></ul></li><li><p>AutomicBoolean中断线程演示：</p><pre class="line-numbers language-none"><code class="language-none">public class InterruptDemo {    static AtomicBoolean atomicBoolean = new AtomicBoolean(false);    public static void main(String[] args) {        new Thread(() -&gt; {            while (true) {                if (atomicBoolean.get()) {                    System.out.println(Thread.currentThread().getName() + " atomicBoolean的值被改为true，t1程序停止");                    break;                }                System.out.println("-----------hello atomicBoolean");            }        }, "t1").start();        try {            TimeUnit.MILLISECONDS.sleep(10);        } catch (InterruptedException e) {            e.printStackTrace();        }        new Thread(() -&gt; {            atomicBoolean.set(true);        }, "t2").start();    }}/** * -----------hello atomicBoolean * -----------hello atomicBoolean * -----------hello atomicBoolean * -----------hello atomicBoolean * -----------hello atomicBoolean * t1 atomicBoolean的值被改为true，t1程序停止 */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><ul><li><p>通过Thread类自带的中断API实例方法实现—-在需要中断的线程中不断监听中断状态，一旦发生中断，就执行相应的中断处理业务逻辑stop线程。</p></li><li><p>interrupt() 和isInterrupted()组合使用来中断某个线程演示：</p><pre class="line-numbers language-none"><code class="language-none">public class InterruptDemo {    static AtomicBoolean atomicBoolean = new AtomicBoolean(false);    public static void main(String[] args) {        Thread t1 = new Thread(() -&gt; {            while (true) {                if (Thread.currentThread().isInterrupted()) {                    System.out.println(Thread.currentThread().getName() + " isInterrupted()的值被改为true，t1程序停止");                    break;                }                System.out.println("-----------hello isInterrupted()");            }        }, "t1");        t1.start();        try {            TimeUnit.MILLISECONDS.sleep(10);        } catch (InterruptedException e) {            e.printStackTrace();        }        //t2向t1放出协商，将t1中的中断标识位设为true，希望t1停下来        new Thread(() -&gt; t1.interrupt(), "t2").start();        //当然，也可以t1自行设置        t1.interrupt();    }}/** * -----------hello isInterrupted() * -----------hello isInterrupted() * -----------hello isInterrupted() * -----------hello isInterrupted() * t1 isInterrupted()的值被改为true，t1程序停止 */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><ul><li>当前线程的中断标识为true，是不是线程就立刻停止？</li></ul></li><li><p>答案是不立刻停止，具体来说，当对一个线程，调用interrupt时：</p></li><li><ul><li><ul><li>如果线程处于正常活动状态，那么会将该线程的中断标志设置为true，仅此而已，被设置中断标志的线程将继续正常运行，不受影响，所以interrupt()并不能真正的中断线程，需要被调用的线程自己进行配合才行，对于不活动的线程没有任何影响。</li><li>如果线程处于阻塞状态（例如sleep,wait,join状态等），在别的线程中调用当前线程对象的interrupt方法，那么线程将立即退出被阻塞状态（interrupt状态也将被清除），并抛出一个InterruptedException异常。</li></ul></li><li><p>第一种情况正常活动状态演示：</p><pre class="line-numbers language-none"><code class="language-none">public class InterruptDemo2 {    public static void main(String[] args) {        //实例方法interrupt()仅仅是设置线程的中断状态位为true，不会停止线程        Thread t1 = new Thread(() -&gt; {            for (int i = 1; i &lt;= 300; i++) {                System.out.println("------: " + i);            }            /**             * ------: 298             * ------: 299             * ------: 300             * t1线程调用interrupt()后的中断标志位02：true             */            System.out.println("t1线程调用interrupt()后的中断标志位02：" + Thread.currentThread().isInterrupted());        }, "t1");        t1.start();        System.out.println("t1线程默认的中断标志位：" + t1.isInterrupted());//false        try {            TimeUnit.MILLISECONDS.sleep(2);        } catch (InterruptedException e) {            e.printStackTrace();        }        t1.interrupt();//true        /**         * ------: 251         * ------: 252         * ------: 253         * t1线程调用interrupt()后的中断标志位01：true         */        System.out.println("t1线程调用interrupt()后的中断标志位01：" + t1.isInterrupted());//true        try {            TimeUnit.MILLISECONDS.sleep(2000);        } catch (InterruptedException e) {            e.printStackTrace();        }        //2000毫秒后，t1线程已经不活动了，不会产生任何影响        System.out.println("t1线程调用interrupt()后的中断标志位03：" + t1.isInterrupted());//false    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>第二种情况线程处于阻塞状态演示：</p><pre class="line-numbers language-none"><code class="language-none">public class InterruptDemo3 {    public static void main(String[] args) {        Thread t1 = new Thread(() -&gt; {            while (true) {                if (Thread.currentThread().isInterrupted()) {                    System.out.println(Thread.currentThread().getName() + " 中断标志位为：" + Thread.currentThread().isInterrupted() + " 程序停止");                    break;                }                //sleep方法抛出InterruptedException后，中断标识也被清空置为false，如果没有在                //catch方法中调用interrupt方法再次将中断标识置为true，这将导致无限循环了                try {                    Thread.sleep(200);                } catch (InterruptedException e) {                    //Thread.currentThread().interrupt();                     e.printStackTrace();                }                System.out.println("-------------hello InterruptDemo3");            }        }, "t1");        t1.start();        try {            TimeUnit.SECONDS.sleep(1);        } catch (InterruptedException e) {            e.printStackTrace();        }        new Thread(() -&gt; {            t1.interrupt();        }, "t2").start();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>对于第二种情况的源码分析如下；</p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/JUC/20.jpg"></p></li></ul></li></ul></li></ul><p>总之，需要记住的是中断只是一种协商机制，修改中断标识位仅此而已，不是立刻stop打断</p><ul><li>静态方法Thread.interrupted()，谈谈你的理解？</li></ul><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/JUC/21.jpg"></p><p>静态方法Thread.interrupted()演示：</p><pre class="line-numbers language-none"><code class="language-none">public class InterruptDemo4 {    public static void main(String[] args) {        /**         * mainfalse         * mainfalse         * -----------1         * -----------2         * maintrue         * mainfalse         */        System.out.println(Thread.currentThread().getName() + "\t" + Thread.interrupted());//false        System.out.println(Thread.currentThread().getName() + "\t" + Thread.interrupted());//false        System.out.println("-----------1");        Thread.currentThread().interrupt();        System.out.println("-----------2");        System.out.println(Thread.currentThread().getName() + "\t" + Thread.interrupted());//true        System.out.println(Thread.currentThread().getName() + "\t" + Thread.interrupted());//false    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于静态方法Thread.interrupted()和实例方法isInterrupted()区别在于：</p><ul><li>静态方法interrupted将会清除中断状态（传入的参数ClearInterrupted为true）</li><li>实例方法isInterrupted则不会（传入的参数ClearInterrupted为false）</li></ul><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/JUC/22.jpg"></p><h4 id="4-1-5-总结"><a href="#4-1-5-总结" class="headerlink" title="4.1.5 总结"></a>4.1.5 总结</h4><ul><li>public void interrupt() 是一个实例方法，它通知目标线程中断，也仅仅是设置目标线程的中断标志位为true</li><li>public boolean isInterrupted() 是一个实例方法，它判断当前线程是否被中断（通过检查中断标志位）并获取中断标志</li><li>public static boolean interrupted() 是一个静态方法，返回当前线程的中断真实状态（boolean类型）后会将当前线程的中断状态设为false，此方法调用之后会清楚当前线程的中断标志位的状态（将中断标志置为false了），返回当前值并清零置为false。</li></ul><h2 id="4-2-LockSupport是什么"><a href="#4-2-LockSupport是什么" class="headerlink" title="4.2 LockSupport是什么"></a>4.2 LockSupport是什么</h2><p>LockSupport是用来创建锁和其他同步类的基本线程阻塞原语，其中park()和unpack()而作用分别是阻塞线程和解除阻塞线程.</p><h2 id="4-3-线程等待唤醒机制"><a href="#4-3-线程等待唤醒机制" class="headerlink" title="4.3 线程等待唤醒机制"></a>4.3 线程等待唤醒机制</h2><h4 id="4-3-1-三种让线程等待和唤醒的方法"><a href="#4-3-1-三种让线程等待和唤醒的方法" class="headerlink" title="4.3.1 三种让线程等待和唤醒的方法"></a>4.3.1 三种让线程等待和唤醒的方法</h4><ul><li>方式一：使用Object中的wait()方法让线程等待，使用Object中的notify()方法唤醒线程</li><li>方式二：使用JUC包中的Condition的await()方法让线程等待，使用signal()方法唤醒线程</li><li>方式三：LockSupport类可以阻塞当前线程以及唤醒指定被阻塞的线程</li></ul><h4 id="4-3-2-Object类中的wait和notify方法实现线程等待和唤醒"><a href="#4-3-2-Object类中的wait和notify方法实现线程等待和唤醒" class="headerlink" title="4.3.2 Object类中的wait和notify方法实现线程等待和唤醒"></a>4.3.2 Object类中的wait和notify方法实现线程等待和唤醒</h4><ul><li>wait和notify方法必须要在同步代码块或者方法里面，且成对出现使用</li><li>先wait再notify才ok</li></ul><p>Object类中的wait和notify方法实现线程等待和唤醒演示:</p><pre class="line-numbers language-none"><code class="language-none">public class LockSupportDemo {    public static void main(String[] args) {        Object objectLock = new Object();        /**         * t1 -----------come in         * t2 -----------发出通知         * t1 -------被唤醒         */        new Thread(() -&gt; {            synchronized (objectLock) {                System.out.println(Thread.currentThread().getName() + "\t -----------come in");                try {                    objectLock.wait();                } catch (InterruptedException e) {                    e.printStackTrace();                }                System.out.println(Thread.currentThread().getName() + "\t -------被唤醒");            }        }, "t1").start();        try {            TimeUnit.SECONDS.sleep(1);        } catch (InterruptedException e) {            e.printStackTrace();        }        new Thread(() -&gt; {            synchronized (objectLock) {                objectLock.notify();                System.out.println(Thread.currentThread().getName() + "\t -----------发出通知");            }        }, "t2").start();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-3-3-Condition接口中的await和signal方法实现线程的等待和唤醒"><a href="#4-3-3-Condition接口中的await和signal方法实现线程的等待和唤醒" class="headerlink" title="4.3.3 Condition接口中的await和signal方法实现线程的等待和唤醒"></a>4.3.3 Condition接口中的await和signal方法实现线程的等待和唤醒</h4><ul><li>Condition中的线程等待和唤醒方法，需要先获取锁</li><li>一定要先await后signal，不要反了</li></ul><p>Condition接口中的await和signal方法实现线程的等待和唤醒演示:</p><pre class="line-numbers language-none"><code class="language-none">public class LockSupportDemo {    public static void main(String[] args) {        Lock lock = new ReentrantLock();        Condition condition = lock.newCondition();        /**         * t1 -----------come in         * t2 -----------发出通知         * t1 -----------被唤醒         */        new Thread(() -&gt; {            lock.lock();            try {                System.out.println(Thread.currentThread().getName() + "\t -----------come in");                condition.await();                System.out.println(Thread.currentThread().getName() + "\t -----------被唤醒");            } catch (InterruptedException e) {                e.printStackTrace();            } finally {                lock.unlock();            }        }, "t1").start();        try {            TimeUnit.SECONDS.sleep(1);        } catch (InterruptedException e) {            e.printStackTrace();        }        new Thread(() -&gt; {            lock.lock();            try {                condition.signal();                System.out.println(Thread.currentThread().getName() + "\t -----------发出通知");            } finally {                lock.unlock();            }        }, "t2").start();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-3-4-上述两个对象Object和Condition使用的限制条件"><a href="#4-3-4-上述两个对象Object和Condition使用的限制条件" class="headerlink" title="4.3.4 上述两个对象Object和Condition使用的限制条件"></a>4.3.4 上述两个对象Object和Condition使用的限制条件</h4><ul><li>线程需要先获得并持有锁，必须在锁块（synchronized或lock）中</li><li>必须要先等待后唤醒，线程才能够被唤醒</li></ul><h4 id="4-3-5-LockSupport类中的park等待和unpark唤醒"><a href="#4-3-5-LockSupport类中的park等待和unpark唤醒" class="headerlink" title="4.3.5 LockSupport类中的park等待和unpark唤醒"></a>4.3.5 LockSupport类中的park等待和unpark唤醒</h4><ul><li><p>是什么</p></li><li><ul><li>LockSupport 是用于创建锁和其他同步类的基本线程阻塞原语</li><li>LockSupport类使用了一种名为Permit（许可）的概念来做到阻塞和唤醒线程的功能，每个线程都有一个许可（Permit），许可证只能有一个，累加上限是1。</li></ul></li><li><p>主要方法</p></li><li><ul><li>阻塞: Peimit许可证默认没有不能放行，所以一开始调用park()方法当前线程会阻塞，直到别的线程给当前线程发放peimit，park方法才会被唤醒。</li></ul></li><li><ul><li><ul><li>park/park(Object blocker)——-阻塞当前线程/阻塞传入的具体线程</li></ul></li></ul></li><li><ul><li>唤醒: 调用unpack(thread)方法后 就会将thread线程的许可证peimit发放，会自动唤醒park线程，即之前阻塞中的LockSupport.park()方法会立即返回。</li></ul></li><li><ul><li><ul><li>unpark(Thread thread)——唤醒处于阻塞状态的指定线程</li></ul></li></ul></li><li><p>代码</p></li></ul><p>LockSupport类中的park等待和unpark唤醒演示:</p><pre class="line-numbers language-none"><code class="language-none">public class LockSupportDemo {    public static void main(String[] args) {        /**         * t1 -----------come in         * t2 ----------发出通知         * t1 ----------被唤醒         */        Thread t1 = new Thread(() -&gt; {            System.out.println(Thread.currentThread().getName() + "\t -----------come in");            LockSupport.park();            System.out.println(Thread.currentThread().getName() + "\t ----------被唤醒");        }, "t1");        t1.start();        try {            TimeUnit.SECONDS.sleep(1);        } catch (InterruptedException e) {            e.printStackTrace();        }        new Thread(() -&gt; {            LockSupport.unpark(t1);            System.out.println(Thread.currentThread().getName() + "\t ----------发出通知");        }, "t2").start();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>重点说明（重要）</p></li><li><ul><li>LockSupport是用来创建锁和其他同步类的基本线程阻塞原语，所有的方法都是静态方法，可以让线程再任意位置阻塞，阻塞后也有对应的唤醒方法。归根结底，LockSupport时调用Unsafe中的native代码</li><li>LockSupport提供park()和unpark()方法实现阻塞线程和解除线程阻塞的过程，LockSupport和每个使用它的线程都有一个许可（Peimit）关联，每个线程都有一个相关的permit，peimit最多只有一个，重复调用unpark也不会积累凭证。</li><li>形象理解：线程阻塞需要消耗凭证（Permit），这个凭证最多只有一个</li></ul></li><li><ul><li><ul><li>当调用park时，如果有凭证，则会直接消耗掉这个凭证然后正常退出。如果没有凭证，则必须阻塞等待凭证可用；</li><li>当调用unpark时，它会增加一个凭证，但凭证最多只能有1各，累加无效。</li></ul></li></ul></li><li><p>面试题</p></li><li><ul><li>为什么LockSupport可以突破wait/notify的原有调用顺序？</li></ul></li><li><ul><li><ul><li>因为unpark获得了一个凭证，之后再调用park方法，就可以名正言顺的凭证消费，故不会阻塞，先发放了凭证后续可以畅通无阻。</li></ul></li></ul></li><li><ul><li>为什么唤醒两次后阻塞两次，但最终结果还会阻塞线程？</li></ul></li><li><ul><li><ul><li>因为凭证的数量最多为1，连续调用两次unpark和调用一次unpark效果一样，只会增加一个凭证，而调用两次park却需要消费两个凭证，证不够，不能放行。</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;LockSupport与线程中断&quot;&gt;&lt;a href=&quot;#LockSupport与线程中断&quot; class=&quot;headerlink&quot; title=&quot;LockSupport与线程中断&quot;&gt;&lt;/a&gt;LockSupport与线程中断&lt;/h1&gt;&lt;h2 id=&quot;4-1-线程中断机</summary>
      
    
    
    
    <category term="JUC并发编程" scheme="https://gitee.com/yunyd/categories/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="JUC并发编程" scheme="https://gitee.com/yunyd/tags/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>说说Java锁事-3</title>
    <link href="https://gitee.com/yunyd/posts/da3e444a.html"/>
    <id>https://gitee.com/yunyd/posts/da3e444a.html</id>
    <published>2023-08-01T01:12:22.000Z</published>
    <updated>2023-08-12T23:24:47.319Z</updated>
    
    <content type="html"><![CDATA[<h1 id="说说Java”锁”事"><a href="#说说Java”锁”事" class="headerlink" title="说说Java”锁”事"></a>说说Java”锁”事</h1><h2 id="3-1-从轻松的乐观锁和悲观锁开讲"><a href="#3-1-从轻松的乐观锁和悲观锁开讲" class="headerlink" title="3.1 从轻松的乐观锁和悲观锁开讲"></a>3.1 从轻松的乐观锁和悲观锁开讲</h2><p>●悲观锁： 认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改，synchronized和Lock的实现类都是悲观锁，适合写操作多的场景，先加锁可以保证写操作时数据正确，显示的锁定之后再操作同步资源—–狼性锁</p><p>●乐观锁： 认为自己在使用数据的时候不会有别的线程修改数据或资源，不会添加锁，Java中使用无锁编程来实现，只是在更新的时候去判断，之前有没有别的线程更新了这个数据，如果这个数据没有被更新，当前线程将自己修改的数据成功写入，如果已经被其他线程更新，则根据不同的实现方式执行不同的操作，比如：放弃修改、重试抢锁等等。判断规则有：版本号机制Version，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。—–适合读操作多的场景，不加锁的特性能够使其读操作的性能大幅提升，乐观锁则直接去操作同步资源，是一种无锁算法，得之我幸不得我命—佛系锁</p><h2 id="3-2-通过8种情况演示锁运行案例，看看锁到底是什么"><a href="#3-2-通过8种情况演示锁运行案例，看看锁到底是什么" class="headerlink" title="3.2 通过8种情况演示锁运行案例，看看锁到底是什么"></a>3.2 通过8种情况演示锁运行案例，看看锁到底是什么</h2><h4 id="3-2-1-锁相关的8种案例演示code"><a href="#3-2-1-锁相关的8种案例演示code" class="headerlink" title="3.2.1 锁相关的8种案例演示code"></a>3.2.1 锁相关的8种案例演示code</h4><p>8种案例演示：</p><pre class="line-numbers language-none"><code class="language-none">class Phone {    public synchronized void sendEmail() {        try {            TimeUnit.SECONDS.sleep(3);        } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.println("------sendEmail");    }    public synchronized void sendSMS() {        System.out.println("------sendSMS");    }    public void hello() {        System.out.println("------hello");    }}/** * 现象描述： * 1 标准访问ab两个线程，请问先打印邮件还是短信？ --------先邮件，后短信  共用一个对象锁 * 2. sendEmail钟加入暂停3秒钟，请问先打印邮件还是短信？---------先邮件，后短信  共用一个对象锁 * 3. 添加一个普通的hello方法，请问先打印普通方法还是邮件？ --------先hello，再邮件 * 4. 有两部手机，请问先打印邮件还是短信？ ----先短信后邮件  资源没有争抢，不是同一个对象锁 * 5. 有两个静态同步方法，一步手机， 请问先打印邮件还是短信？---------先邮件后短信  共用一个类锁 * 6. 有两个静态同步方法，两部手机， 请问先打印邮件还是短信？ ----------先邮件后短信 共用一个类锁 * 7. 有一个静态同步方法 一个普通同步方法，请问先打印邮件还是短信？ ---------先短信后邮件   一个用类锁一个用对象锁 * 8. 有一个静态同步方法，一个普通同步方法，两部手机，请问先打印邮件还是短信？ -------先短信后邮件 一个类锁一个对象锁 */public class Lock8Demo {    public static void main(String[] args) {        Phone phone = new Phone();        new Thread(() -&gt; {            phone.sendEmail();        }, "a").start();        try {            TimeUnit.MILLISECONDS.sleep(200);        } catch (InterruptedException e) {            e.printStackTrace();        }        new Thread(() -&gt; {            phone.sendSMS();        }, "b").start();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结论：</p><ul><li>对于普通同步方法，锁的是当前实例对象，通常指this，所有的同步方法用的都是同一把锁—&gt;实例对象本身</li><li>对于静态同步方法，锁的时当前类的Class对象</li><li>对于同步方法块，锁的时synchronized括号内的对象</li></ul><h4 id="3-2-2-synchronized有三种应用方式"><a href="#3-2-2-synchronized有三种应用方式" class="headerlink" title="3.2.2 synchronized有三种应用方式"></a>3.2.2 synchronized有三种应用方式</h4><ul><li>作用于实例方法，当前实例加锁，进入同步代码块前要获得当前实例的锁；</li><li>作用于代码块，对括号里配置的对象加锁</li><li>作用于静态方法，当前类加锁，进去同步代码前要获得当前类对象的锁</li></ul><h4 id="3-2-3-从字节码角度分析synchronized实现"><a href="#3-2-3-从字节码角度分析synchronized实现" class="headerlink" title="3.2.3 从字节码角度分析synchronized实现"></a>3.2.3 从字节码角度分析synchronized实现</h4><ul><li><p>javap -c(v附加信息) ***.class 文件反编译</p></li><li><p>synchronized同步代码块</p></li><li><p>实现使用的是monitorenter和monitorexit指令</p></li><li><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/JUC/11.jpg"></p></li><li><p>synchronized普通同步方法</p></li><li><ul><li>调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程会将现持有monitor锁，然后再执行该方法，最后在方法完成（无论是否正常结束）时释放monitor</li></ul></li></ul><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/JUC/12.jpg"></p><ul><li><p>synchronized静态同步方法</p></li><li><ul><li>ACC_STATIC、ACC_SYNCHRONIZED访问标志区分该方法是否是静态同步方法</li></ul></li></ul><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/JUC/13.jpg"></p><h4 id="3-2-4-反编译synchronized锁的是什么"><a href="#3-2-4-反编译synchronized锁的是什么" class="headerlink" title="3.2.4 反编译synchronized锁的是什么"></a>3.2.4 反编译synchronized锁的是什么</h4><p>面试题：为什么任何一个对象都可以成为一个锁？</p><p>C++源码：ObjectMonitor.java—&gt;ObjectMonitor.cpp—&gt;ObjectMonitor.hpp</p><p>每个对象天生都带着一个对象监视器，每一个被锁住的对象都会和Monitor关联起来</p><p>总结：指针指向Monitor对象（也称为管程或监视器）的真实地址。每个对象都存在着一个monitor与之关联，当一个monitor被某个线程持有后，它便处于锁定状态。在Java虚拟机（HotSpot）中，monitor是由OnjectMonitor实现的，其主要的数据结构如下（位于HotSpot虚拟机源码ObjectMonitor.hpp文件，C++实现）：</p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/JUC/14.jpg"></p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/JUC/15.jpg"></p><h4 id="3-2-5-对于Synchronized关键字"><a href="#3-2-5-对于Synchronized关键字" class="headerlink" title="3.2.5 对于Synchronized关键字"></a>3.2.5 对于Synchronized关键字</h4><p>后面章节详说</p><h2 id="3-3-公平锁和非公平锁"><a href="#3-3-公平锁和非公平锁" class="headerlink" title="3.3 公平锁和非公平锁"></a>3.3 公平锁和非公平锁</h2><h4 id="3-3-1-何为公平锁-非公平锁"><a href="#3-3-1-何为公平锁-非公平锁" class="headerlink" title="3.3.1 何为公平锁/非公平锁"></a>3.3.1 何为公平锁/非公平锁</h4><ul><li>公平锁：是指多个线程按照申请锁的顺序来获取锁，这里类似于排队买票，先来的人先买，后来的人再队尾排着，这是公平的—– Lock lock = new ReentrantLock(true)—表示公平锁，先来先得。</li><li>非公平锁：是指多个线程获取锁的顺序并不是按照申请的顺序，有可能后申请的线程比先申请的线程优先获取锁，在高并发环境下，有可能造成优先级反转或者饥饿的状态（某个线程一直得不到锁）—- Lock lock = new  ReentrantLock(false)—表示非公平锁，后来的也可能先获得锁，默认为非公平锁。</li></ul><p>面试题：</p><ul><li><p>为什么会有公平锁/非公平锁的设计？为什么默认非公平？</p></li><li><ul><li>恢复挂起的线程到真正锁的获取还是有时间差的，从开发人员来看这个时间微乎其微，但是从CPU的角度来看，这个时间差存在的还是很明显的。所以非公平锁能更充分地利用CPU的时间片，尽量减少CPU空间状态时间。</li><li>使用多线程很重要的考量点是线程切换的开销，当采用非公平锁时，当一个线程请求锁获取同步状态，然后释放同步状态，所以刚释放锁的线程在此刻再次获取同步状态的概率就变得很大，所以就减少了线程的开销。</li></ul></li><li><p>什么时候用公平？什么时候用非公平？</p></li><li><ul><li>如果为了更高的吞吐量，很显然非公平锁是比较合适的，因为节省了很多线程切换的时间，吞吐量自然就上去了；否则就用公平锁，大家公平使用。</li></ul></li></ul><h4 id="3-3-2-预埋伏AQS"><a href="#3-3-2-预埋伏AQS" class="headerlink" title="3.3.2 预埋伏AQS"></a>3.3.2 预埋伏AQS</h4><p>后续深入分析</p><h1 id="3-4-可重入锁（递归锁）"><a href="#3-4-可重入锁（递归锁）" class="headerlink" title="3.4 可重入锁（递归锁）"></a>3.4 可重入锁（递归锁）</h1><h2 id="3-4-1-概念说明"><a href="#3-4-1-概念说明" class="headerlink" title="3.4.1 概念说明"></a>3.4.1 概念说明</h2><p>是指在同一线程在外层方法获取到锁的时侯，在进入该线程的内层方法会自动获取锁（前提，锁对象的是同一个对象），不会因为之前已经获取过还没释放而阻塞———优点之一就是可一定程度避免死锁。</p><h2 id="3-4-2-可重入锁种类"><a href="#3-4-2-可重入锁种类" class="headerlink" title="3.4.2 可重入锁种类"></a>3.4.2 可重入锁种类</h2><ul><li><p>隐式锁（即synchronized关键字使用的锁），默认是可重入锁</p></li><li><ul><li>在一个synchronized修饰的方法或者代码块的内部调用本类的其他synchronized修饰的方法或者代码块时，是永远可以得到锁。</li></ul></li><li><p>显式锁（即Lock）也有ReentrantLock这样的可重入锁</p></li></ul><p>隐式和显示可重入锁的演示：</p><pre class="line-numbers language-none"><code class="language-none">public class ReEntryLockDemo {    public static void main(String[] args) {        final Object o = new Object();        /**         * ---------------外层调用         * ---------------中层调用         * ---------------内层调用         */        new Thread(() -&gt; {            synchronized (o) {                System.out.println("---------------外层调用");                synchronized (o) {                    System.out.println("---------------中层调用");                    synchronized (o) {                        System.out.println("---------------内层调用");                    }                }            }        }, "t1").start();        /**         * 注意：加锁几次就需要解锁几次         * ---------------外层调用         * ---------------中层调用         * ---------------内层调用         */        Lock lock = new ReentrantLock();        new Thread(() -&gt; {            lock.lock();            try {                System.out.println("---------------外层调用");                lock.lock();                try {                    System.out.println("---------------中层调用");                    lock.lock();                    try {                        System.out.println("---------------内层调用");                    } finally {                        lock.unlock();                    }                } finally {                    lock.unlock();                }            } finally {                lock.unlock();            }        }, "t2").start();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-5-死锁及排查"><a href="#3-5-死锁及排查" class="headerlink" title="3.5 死锁及排查"></a>3.5 死锁及排查</h2><h4 id="3-5-1-概念"><a href="#3-5-1-概念" class="headerlink" title="3.5.1 概念"></a>3.5.1 概念</h4><p>死锁是指两个或两个以上的线程在执行过程中，因抢夺资源而造成的一种互相等待的现象，若无外力干涉，则它们无法再继续推进下去。</p><p>产生原因：</p><ul><li>系统资源不足</li><li>进程运行推进顺序不合适</li><li>系统资源分配不当</li></ul><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/JUC/16.jpg"></p><h4 id="3-5-2-写一个死锁代码case"><a href="#3-5-2-写一个死锁代码case" class="headerlink" title="3.5.2 写一个死锁代码case"></a>3.5.2 写一个死锁代码case</h4><p>实现死锁：</p><pre class="line-numbers language-none"><code class="language-none">public class DeadLockDemo {    static  Object a=new Object();    static  Object b=new Object();    public static void main(String[] args) {        new Thread(() -&gt; {            synchronized (a){                System.out.println("t1线程持有a锁，试图获取b锁");                try {                    TimeUnit.SECONDS.sleep(1);                } catch (InterruptedException e) {                    e.printStackTrace();                }                synchronized (b){                    System.out.println("t1线程获取到b锁");                }            }         },"t1").start();        new Thread(() -&gt; {            synchronized (b){                System.out.println("t2线程持有a锁，试图获取a锁");                try {                    TimeUnit.SECONDS.sleep(1);                } catch (InterruptedException e) {                    e.printStackTrace();                }                synchronized (a){                    System.out.println("t2线程获取到a锁");                }            }        },"t2").start();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-5-3-如何排查死锁"><a href="#3-5-3-如何排查死锁" class="headerlink" title="3.5.3 如何排查死锁"></a>3.5.3 如何排查死锁</h4><ul><li><p>纯命令</p></li><li><ul><li>jps -l</li><li>jstack 进程编号</li></ul></li><li><p>图形化</p></li><li><ul><li>jconsole</li></ul></li><li><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/JUC/17.jpg"></p></li></ul><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/JUC/18.jpg"></p><h2 id="3-6-写锁（独占锁）-读锁（共享锁）"><a href="#3-6-写锁（独占锁）-读锁（共享锁）" class="headerlink" title="3.6 写锁（独占锁）/读锁（共享锁）"></a>3.6 写锁（独占锁）/读锁（共享锁）</h2><p>深度源码分析见后面</p><h2 id="3-7-自旋锁spinLock"><a href="#3-7-自旋锁spinLock" class="headerlink" title="3.7 自旋锁spinLock"></a>3.7 自旋锁spinLock</h2><p>深度源码分析见后面</p><h2 id="3-8-无锁-gt-独占锁-gt-读写锁-gt-邮戳锁"><a href="#3-8-无锁-gt-独占锁-gt-读写锁-gt-邮戳锁" class="headerlink" title="3.8 无锁->独占锁->读写锁->邮戳锁"></a>3.8 无锁-&gt;独占锁-&gt;读写锁-&gt;邮戳锁</h2><p>深度源码分析见后面</p><h2 id="3-9-无锁-gt-偏向锁-gt-轻量锁-gt-重量锁"><a href="#3-9-无锁-gt-偏向锁-gt-轻量锁-gt-重量锁" class="headerlink" title="3.9 无锁->偏向锁->轻量锁->重量锁"></a>3.9 无锁-&gt;偏向锁-&gt;轻量锁-&gt;重量锁</h2><p>深度源码分析见后面</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;说说Java”锁”事&quot;&gt;&lt;a href=&quot;#说说Java”锁”事&quot; class=&quot;headerlink&quot; title=&quot;说说Java”锁”事&quot;&gt;&lt;/a&gt;说说Java”锁”事&lt;/h1&gt;&lt;h2 id=&quot;3-1-从轻松的乐观锁和悲观锁开讲&quot;&gt;&lt;a href=&quot;#3-1-</summary>
      
    
    
    
    <category term="JUC并发编程" scheme="https://gitee.com/yunyd/categories/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="JUC并发编程" scheme="https://gitee.com/yunyd/tags/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CompletableFuture-2</title>
    <link href="https://gitee.com/yunyd/posts/1fb3c234.html"/>
    <id>https://gitee.com/yunyd/posts/1fb3c234.html</id>
    <published>2023-07-28T02:12:22.000Z</published>
    <updated>2023-08-12T23:27:44.827Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h1><h2 id="2-1-Future接口理论知识复习"><a href="#2-1-Future接口理论知识复习" class="headerlink" title="2.1 Future接口理论知识复习"></a>2.1 Future接口理论知识复习</h2><p>Future接口（FutureTask实现类）定义了操作异步任务执行一些方法，如获取异步任务的执行结果、取消异步任务的执行、判断任务是否被取消、判断任务执行是否完毕等。</p><p>举例：比如主线程让一个子线程去执行任务，子线程可能比较耗时，启动子线程开始执行任务后，主线程就去做其他事情了，忙完其他事情或者先执行完，过了一会再才去获取子任务的执行结果或变更的任务状态（老师上课时间想喝水，他继续讲课不结束上课这个主线程，让学生去小卖部帮老师买水完成这个耗时和费力的任务）。</p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/JUC/1.jpg"></p><h2 id="2-2-Future接口常用实现类FutureTask异步任务"><a href="#2-2-Future接口常用实现类FutureTask异步任务" class="headerlink" title="2.2 Future接口常用实现类FutureTask异步任务"></a>2.2 Future接口常用实现类FutureTask异步任务</h2><h4 id="2-2-1-Future接口能干什么"><a href="#2-2-1-Future接口能干什么" class="headerlink" title="2.2.1 Future接口能干什么"></a>2.2.1 Future接口能干什么</h4><p>Future是Java5新加的一个接口，它提供一种异步并行计算的功能，如果主线程需要执行一个很耗时的计算任务，我们会就可以通过Future把这个任务放进异步线程中执行，主线程继续处理其他任务或者先行结束，再通过Future获取计算结果。</p><h4 id="2-2-2-Future接口相关架构"><a href="#2-2-2-Future接口相关架构" class="headerlink" title="2.2.2 Future接口相关架构"></a>2.2.2 Future接口相关架构</h4><p>●目的：异步多线程任务执行且返回有结果，三个特点：多线程、有返回、异步任务（班长为老师去买水作为新启动的异步多线程任务且买到水有结果返回）</p><p>●代码实现：Runnable接口+Callable接口+Future接口和FutureTask实现类。</p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/JUC/2.jpg"></p><p>FutureTask开启异步任务：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class CompletableFutureDemo {    public static void main(String[] args) throws ExecutionException, InterruptedException {        FutureTask&lt;String&gt; futureTask = new FutureTask(new MyThread());        Thread t1 = new Thread(futureTask); //开启一个异步线程        t1.start();        System.out.println(futureTask.get()); //有返回hello Callable    }}class MyThread implements Callable&lt;String&gt; {    @Override    public String call() throws Exception {        System.out.println("--------come in");        return "hello Callable";    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-3-Future编码实战和优缺点分析"><a href="#2-2-3-Future编码实战和优缺点分析" class="headerlink" title="2.2.3 Future编码实战和优缺点分析"></a>2.2.3 Future编码实战和优缺点分析</h4><p>●优点：Future+线程池异步多线程任务配合，能显著提高程序的运行效率。</p><p>●缺点：</p><p>​    ○get()阻塞—一旦调用get()方法求结果，一旦调用不见不散，非要等到结果才会离开，不管你是否计算完成，如果没有计算完成容易程序堵塞。</p><p>​    ○isDone()轮询—轮询的方式会耗费无谓的cpu资源，而且也不见得能及时得到计算结果，如果想要异步获取结果，通常会以轮询的方式去获取结果，尽量不要阻塞。</p><p>●结论：Future对于结果的获取不是很友好，只能通过阻塞或轮询的方式得到任务的结果。</p><p>Future获取结果get()和轮询：</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class FutureApiDemo {    public static void main(String[] args) throws ExecutionException, InterruptedException, TimeoutException {        FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(() -&gt; {            System.out.println(Thread.currentThread().getName() + "--------come in");            try {                TimeUnit.SECONDS.sleep(5);            } catch (InterruptedException e) {                e.printStackTrace();            }            return "task over";        });        Thread t1 = new Thread(futureTask, "t1");        t1.start();//        System.out.println(futureTask.get());//这样会有阻塞的可能，在程序没有计算完毕的情况下。        System.out.println(Thread.currentThread().getName() + " ------忙其他任务");//        System.out.println(futureTask.get(3,TimeUnit.SECONDS));//只愿意等待三秒，计算未完成直接抛出异常        while (true) {//轮询            if(futureTask.isDone()){                System.out.println(futureTask.get());                break;            }else{                TimeUnit.MILLISECONDS.sleep(500);                System.out.println("正在处理中，不要催了，越催越慢");            }        }        /* 轮询结果        * main ------忙其他任务        t1--------come in        正在处理中，不要催了，越催越慢        正在处理中，不要催了，越催越慢        正在处理中，不要催了，越催越慢        正在处理中，不要催了，越催越慢        正在处理中，不要催了，越催越慢        正在处理中，不要催了，越催越慢        正在处理中，不要催了，越催越慢        正在处理中，不要催了，越催越慢        正在处理中，不要催了，越催越慢        正在处理中，不要催了，越催越慢        task over        Process finished with exit code 0        * */    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-4-完成一些复杂的任务"><a href="#2-2-4-完成一些复杂的任务" class="headerlink" title="2.2.4 完成一些复杂的任务"></a>2.2.4 完成一些复杂的任务</h4><p>●对于简单的业务场景使用Future完全ok</p><p>●回调通知：</p><p>​            ○应对Future的完成时间，完成了可以告诉我，也就是我们的回调通知</p><p>​            ○通过轮询的方式去判断任务是否完成这样非常占cpu并且代码也不优雅</p><p>●创建异步任务：Future+线程池组合</p><p>●多个任务前后依赖可以组合处理（水煮鱼—&gt;买鱼—&gt;调料—&gt;下锅）：</p><p>​            ○想将多个异步任务的结果组合起来，后一个异步任务的计算结果需要钱一个异步任务的值</p><p>​            ○想将两个或多个异步计算合并成为一个异步计算，这几个异步计算互相独立，同时后面这个又依赖前一个处理的结果</p><p>●对计算速度选最快的：</p><p>​            ○当Future集合中某个任务最快结束时，返回结果，返回第一名处理结果</p><p>●结论：</p><p>​           ○使用Future之前提供的那点API就囊中羞涩，处理起来不够优雅，这时候还是让CompletableFuture以声明式的方式优雅的处理这些需求。</p><p>​            ○从i到i++</p><p>​            ○Future能干的，CompletableFuture都能干</p><h2 id="2-3-CompletableFuture对Future的改进"><a href="#2-3-CompletableFuture对Future的改进" class="headerlink" title="2.3 CompletableFuture对Future的改进"></a>2.3 CompletableFuture对Future的改进</h2><h4 id="2-3-1-CompletableFuture为什么会出现"><a href="#2-3-1-CompletableFuture为什么会出现" class="headerlink" title="2.3.1 CompletableFuture为什么会出现"></a>2.3.1 CompletableFuture为什么会出现</h4><p>●get()方法在Future计算完成之前会一直处在阻塞状态下，阻塞的方式和异步编程的设计理念相违背。</p><p>●isDene()方法容易耗费cpu资源（cpu空转），</p><p>●对于真正的异步处理我们希望是可以通过传入回调函数，在Future结束时自动调用该回调函数，这样，我们就不用等待结果</p><p>jdk8设计出CompletableFuture，CompletableFuture提供了一种观察者模式类似的机制，可以让任务执行完成后通知监听的一方。</p><h4 id="2-3-2-CompletableFuture和CompletionStage介绍"><a href="#2-3-2-CompletableFuture和CompletionStage介绍" class="headerlink" title="2.3.2 CompletableFuture和CompletionStage介绍"></a>2.3.2 CompletableFuture和CompletionStage介绍</h4><p>类架构说明：</p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/JUC/3.jpg"></p><p><strong>●</strong>接口CompletionStage</p><p>​            ○代表异步计算过程中的某一个阶段，一个阶段完成以后可能会触发另外一个阶段。</p><p>​            ○一个阶段的执行可能是被单个阶段的完成触发，也可能是由多个阶段一起触发</p><p><strong>●</strong>类CompletableFuture</p><p>​            ○提供了非常强大的Future的扩展功能，可以帮助我们简化异步编程的复杂性，并且提供了函数式编程的能力，可以通过回调的方式处理计算结果，也提供了转换和组合CompletableFuture的方法</p><p>​            ○它可能代表一个明确完成的Future，也可能代表一个完成阶段（CompletionStage），它支持在计算完成以后触发一些函数或执行某些动作</p><h4 id="2-3-3-核心的四个静态方法，来创建一个异步任务"><a href="#2-3-3-核心的四个静态方法，来创建一个异步任务" class="headerlink" title="2.3.3 核心的四个静态方法，来创建一个异步任务"></a>2.3.3 核心的四个静态方法，来创建一个异步任务</h4><p>四个静态构造方法</p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/JUC/4.jpg"></p><p>对于上述Executor参数说明：若没有指定，则使用默认的ForkJoinPoolcommonPool（）作为它的线程池执行异步代码，如果指定线程池，则使用我们自定义的或者特别指定的线程池执行异步代码</p><p>四个静态方法演示:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CompletableFutureBuildDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>        <span class="token class-name">ExecutorService</span> executorService <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> completableFuture <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">runAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>executorService<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>completableFuture<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//null</span>        <span class="token class-name">CompletableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> objectCompletableFuture <span class="token operator">=</span> <span class="token class-name">CompletableFuture</span><span class="token punctuation">.</span><span class="token function">supplyAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token string">"hello supplyAsync"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>executorService<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>objectCompletableFuture<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//hello supplyAsync</span>        executorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>CompletableFuture减少阻塞和轮询，可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法。</p><p>CompletableFuture使用演示:</p><pre class="line-numbers language-none"><code class="language-none">public class CompletableFutureUseDemo {    public static void main(String[] args) throws ExecutionException, InterruptedException {        ExecutorService executorService = Executors.newFixedThreadPool(3);        CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; {            System.out.println(Thread.currentThread().getName() + "---come in");            int result = ThreadLocalRandom.current().nextInt(10);            try {                TimeUnit.SECONDS.sleep(1);            } catch (InterruptedException e) {                e.printStackTrace();            }            if (result &gt; 5) { //模拟产生异常情况                int i = 10 / 0;            }            System.out.println("----------1秒钟后出结果" + result);            return result;        }, executorService).whenComplete((v, e) -&gt; {            if (e == null) {                System.out.println("计算完成 更新系统" + v);            }        }).exceptionally(e -&gt; {            e.printStackTrace();            System.out.println("异常情况：" + e.getCause() + " " + e.getMessage());            return null;        });        System.out.println(Thread.currentThread().getName() + "先去完成其他任务");        executorService.shutdown();    }}/** * 无异常情况 * pool-1-thread-1---come in * main先去完成其他任务 * ----------1秒钟后出结果9 * 计算完成 更新系统9 *//** * 有异常情况 *pool-1-thread-1---come in * main先去完成其他任务 * java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zero * 异常情况：java.lang.ArithmeticException: / by zero java.lang.ArithmeticException: / by zero */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>CompletableFuture优点：</p><p>●异步任务结束时，会自动回调某个对象的方法</p><p>●主线程设置好回调后，不用关心异步任务的执行，异步任务之间可以顺序执行</p><p>●异步任务出错时，会自动回调某个对象的方法</p><h2 id="2-4-案例精讲-从电商网站的比价需求展开"><a href="#2-4-案例精讲-从电商网站的比价需求展开" class="headerlink" title="2.4 案例精讲-从电商网站的比价需求展开"></a>2.4 案例精讲-从电商网站的比价需求展开</h2><h4 id="2-4-1-函数式编程已成为主流"><a href="#2-4-1-函数式编程已成为主流" class="headerlink" title="2.4.1 函数式编程已成为主流"></a>2.4.1 函数式编程已成为主流</h4><p>Lambda表达式+Stream流式调用+Chain链式调用+Java8函数式编程</p><p>函数时接口：</p><p>●Runnable：无参数、无返回值</p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/JUC/5.jpg"></p><p>●Function：接受一个参数，并且有返回值</p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/JUC/6.jpg"></p><p>●Consumer：接受一个参数，没有返回值</p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/JUC/7.jpg"></p><p>​        ○BiConsumer：接受两个参数，没有返回值</p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/JUC/8.jpg"></p><p>●Supplier：没有参数，有返回值</p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/JUC/9.jpg"></p><p>小结：</p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/JUC/10.jpg"></p><p>chain链式调用：</p><pre class="line-numbers language-none"><code class="language-none">public class CompletableFutureMallDemo {    public static void main(String[] args) {        Student student = new Student();        student.setId(1).setStudentName("z3").setMajor("english"); //链式调用    }}@AllArgsConstructor@NoArgsConstructor@Data@Accessors(chain = true)//开启链式调用class Student {    private Integer id;    private String studentName;    private String major;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-4-2-大厂业务需求说明"><a href="#2-4-2-大厂业务需求说明" class="headerlink" title="2.4.2 大厂业务需求说明"></a>2.4.2 大厂业务需求说明</h4><p>切记：功能—&gt;性能（完成—&gt;完美）</p><p>电商网站比价需求分析：</p><p>1.需求说明：</p><p>​    a同一款产品，同时搜索出同款产品在各大电商平台的售价</p><p>​    b同一款产品，同时搜索出本产品在同一个电商平台下，各个入驻卖家售价是多少</p><p>2.输出返回：</p><p>​    a出来结果希望是同款产品的在不同地方的价格清单列表，返回一个List<string></string></p><p>​    例如：《Mysql》 in jd price is 88.05  《Mysql》 in taobao price is 90.43</p><p>3.解决方案，对比同一个产品在各个平台上的价格，要求获得一个清单列表</p><p>astep by step，按部就班，查完淘宝查京东，查完京东查天猫….</p><p>ball in，万箭齐发，一口气多线程异步任务同时查询</p><h4 id="2-4-3-一波流Java8函数式编程带走-比价案例实战Case"><a href="#2-4-3-一波流Java8函数式编程带走-比价案例实战Case" class="headerlink" title="2.4.3 一波流Java8函数式编程带走-比价案例实战Case"></a>2.4.3 一波流Java8函数式编程带走-比价案例实战Case</h4><p>比价实战Case:</p><pre class="line-numbers language-none"><code class="language-none">public class CompletableFutureMallDemo {    static List&lt;NetMall&gt; list = Arrays.asList(new NetMall("jd"), new NetMall("taobao"), new NetMall("dangdang"));    /**     * step by step     * @param list     * @param productName     * @return     */    public static List&lt;String&gt; getPrice(List&lt;NetMall&gt; list, String productName) {        //《Mysql》 in jd price is 88.05        return list                .stream()                .map(netMall -&gt;                        String.format("《" + productName + "》" + "in %s price is %.2f",                                netMall.getNetMallName(),                                netMall.calcPrice(productName)))                .collect(Collectors.toList());    }    /**     * all in     * 把list里面的内容映射给CompletableFuture()     * @param list     * @param productName     * @return     */    public static List&lt;String&gt; getPriceByCompletableFuture(List&lt;NetMall&gt; list, String productName) {        return list.stream().map(netMall -&gt;                        CompletableFuture.supplyAsync(() -&gt;                                String.format("《" + productName + "》" + "in %s price is %.2f",                                        netMall.getNetMallName(),                                        netMall.calcPrice(productName)))) //Stream&lt;CompletableFuture&lt;String&gt;&gt;                .collect(Collectors.toList()) //List&lt;CompletableFuture&lt;String&gt;&gt;                .stream()//Stream&lt;String&gt;                .map(s -&gt; s.join()).collect(Collectors.toList()); //List&lt;String&gt;    }    public static void main(String[] args) {        /**         * 采用step by setp方式查询         * 《masql》in jd price is 110.11         * 《masql》in taobao price is 109.32         * 《masql》in dangdang price is 109.24         * ------costTime: 3094 毫秒         */        long StartTime = System.currentTimeMillis();        List&lt;String&gt; list1 = getPrice(list, "masql");        for (String element : list1) {            System.out.println(element);        }        long endTime = System.currentTimeMillis();        System.out.println("------costTime: " + (endTime - StartTime) + " 毫秒");        /**         * 采用 all in三个异步线程方式查询         * 《mysql》in jd price is 109.71         * 《mysql》in taobao price is 110.69         * 《mysql》in dangdang price is 109.28         * ------costTime1009 毫秒         */        long StartTime2 = System.currentTimeMillis();        List&lt;String&gt; list2 = getPriceByCompletableFuture(list, "mysql");        for (String element : list2) {            System.out.println(element);        }        long endTime2 = System.currentTimeMillis();        System.out.println("------costTime" + (endTime2 - StartTime2) + " 毫秒");    }}@AllArgsConstructor@NoArgsConstructor@Dataclass NetMall {    private String netMallName;    public double calcPrice(String productName) {        try {            TimeUnit.SECONDS.sleep(1);        } catch (InterruptedException e) {            e.printStackTrace();        }        return ThreadLocalRandom.current().nextDouble() * 2 + productName.charAt(0);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-4-4-CompletableFuture常用方法"><a href="#2-4-4-CompletableFuture常用方法" class="headerlink" title="2.4.4 CompletableFuture常用方法"></a>2.4.4 CompletableFuture常用方法</h4><p><strong>●</strong>获得结果和触发计算</p><p>​                ○获取结果</p><p>​                            ■public T get()</p><p>​                            ■public T get(long timeout,TimeUnit unit)</p><p>​                            ■public T join() —&gt;和get一样的作用，只是不需要抛出异常</p><p>​                            ■public T getNow(T valuelfAbsent) —&gt;计算完成就返回正常值，否则返回备胎值（传入的参数），立即获取结果不阻塞</p><p>​                ○主动触发计算</p><p>​                            ■public boolean complete(T value) —-&gt;是否打断get方法立即返回括号值</p><p><strong>●</strong>对计算结果进行处理</p><p>​            ○thenApply —&gt;计算结果存在依赖关系，这两个线程串行化—-&gt;由于存在依赖关系（当前步错，不走下一步），当前步骤有异常的话就叫停</p><p>​            ○handle —&gt;计算结果存在依赖关系，这两个线程串行化—-&gt;有异常也可以往下走一步</p><p>对计算结果进行处理演示:</p><pre class="line-numbers language-none"><code class="language-none">public class CompletableFutureApiDemo {    public static void main(String[] args) throws ExecutionException, InterruptedException, TimeoutException {        ExecutorService threadPool = Executors.newFixedThreadPool(3);        CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; {            try {                TimeUnit.SECONDS.sleep(1);            } catch (InterruptedException e) {                e.printStackTrace();            }            return 1;        }, threadPool).thenApply(f -&gt; {            System.out.println("222");            return f + 2;        }).handle((f, e) -&gt; {            System.out.println("3333");            int i=10/0;            return f + 2;//             thenApply(f -&gt; {//            System.out.println("3333");//            return f + 2;        }).whenComplete((v, e) -&gt; {            if (e == null) {                System.out.println("----计算结果" + v);            }        }).exceptionally(e -&gt; {            e.printStackTrace();            System.out.println(e.getCause());            return null;        });        System.out.println(Thread.currentThread().getName() + "------主线程先去做其他事情");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>●</strong>对计算结果进行消费</p><p>​            ○接受任务的处理结果，并消费处理，无返回结果</p><p>​            ○thenAccept</p><p>thenAccetp演示:</p><pre class="line-numbers language-none"><code class="language-none">public class CompletableFutureApi2Demo {    public static void main(String[] args) {        ExecutorService threadPool = Executors.newFixedThreadPool(3);        CompletableFuture.supplyAsync(() -&gt; {            return 1;        }, threadPool).thenApply(f -&gt; {            return f + 2;        }).thenApply(f -&gt; {            return f + 2;        }).thenAccept(r -&gt; {            System.out.println(r);//5        });    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​            ○对比补充</p><p>​                        ■thenRun(Runnable runnable) :任务A执行完执行B，并且不需要A的结果</p><p>​                        ■thenAccept(Consumer action): 任务A执行完执行B，B需要A的结果，但是任务B没有返回值</p><p>​                        ■thenApply(Function fn): 任务A执行完执行B，B需要A的结果，同时任务B有返回值</p><p>对比补充:</p><pre class="line-numbers language-none"><code class="language-none">public class CompletableFutureApi2Demo {    public static void main(String[] args) {        System.out.println(CompletableFuture.supplyAsync(() -&gt; "result").thenRun(() -&gt; {}).join());//null        System.out.println(CompletableFuture.supplyAsync(() -&gt; "result").thenAccept(r -&gt; System.out.println(r)).join());//result null        System.out.println(CompletableFuture.supplyAsync(() -&gt; "result").thenApply(f -&gt; f + 2).join());//result2    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​            ○CompletableFuture和线程池说明</p><p>​                    ■如果没有传入自定义线程池，都用默认线程池ForkJoinPool</p><p>​                    ■传入一个线程池，如果你执行第一个任务时，传入了一个自定义线程池</p><p>●调用thenRun方法执行第二个任务时，则第二个任务和第一个任务时共用同一个线程池</p><p>●调用thenRunAsync执行第二个任务时，则第一个任务使用的是你自定义的线程池，第二个任务使用的是ForkJoin线程池</p><p>​                    ■备注：可能是线程处理太快，系统优化切换原则， 直接使用main线程处理，thenAccept和thenAcceptAsync，thenApply和thenApplyAsync等，之间的区别同理。</p><p><strong>●</strong>对计算速度进行选用</p><p>​        ○谁快用谁</p><p>​        ○applyToEither</p><p>applyToEither演示:</p><pre class="line-numbers language-none"><code class="language-none">public class CompletableFutureApiDemo {    public static void main(String[] args) {        ExecutorService threadPool = Executors.newFixedThreadPool(3);        CompletableFuture&lt;String&gt; playA = CompletableFuture.supplyAsync(() -&gt; {            try {                System.out.println("A come in");                TimeUnit.SECONDS.sleep(2);            } catch (InterruptedException e) {                e.printStackTrace();            }            return "playA";        }, threadPool);        CompletableFuture&lt;String&gt; playB = CompletableFuture.supplyAsync(() -&gt; {            try {                System.out.println("B come in");                TimeUnit.SECONDS.sleep(3);            } catch (InterruptedException e) {                e.printStackTrace();            }            return "playB";        }, threadPool);        CompletableFuture&lt;String&gt; result = playA.applyToEither(playB, f -&gt; {            return f + " is winner";        });        /**         * A come in         * B come in         * main-----------winner:playA is winner         */        System.out.println(Thread.currentThread().getName() + "-----------winner:" + result.join());    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>●</strong>对计算结果进行合并</p><p>​                ○两个CompletableStage任务都完成后，最终能把两个任务的结果一起交给thenCombine来处理</p><p>​                ○先完成的先等着，等待其他分支任务</p><p>thenCombine演示:</p><pre class="line-numbers language-none"><code class="language-none">public class CompletableFutureApi3Demo {    public static void main(String[] args) {        CompletableFuture&lt;Integer&gt; completableFuture1 = CompletableFuture.supplyAsync(() -&gt; {            System.out.println(Thread.currentThread().getName() + " 启动");            try {                TimeUnit.SECONDS.sleep(1);            } catch (InterruptedException e) {                e.printStackTrace();            }            return 10;        });        CompletableFuture&lt;Integer&gt; completableFuture2 = CompletableFuture.supplyAsync(() -&gt; {            System.out.println(Thread.currentThread().getName() + " 启动");            try {                TimeUnit.SECONDS.sleep(2);            } catch (InterruptedException e) {                e.printStackTrace();            }            return 20;        });        CompletableFuture&lt;Integer&gt; finalResult = completableFuture1.thenCombine(completableFuture2, (x, y) -&gt; {            System.out.println("----------开始两个结果合并");            return x + y;        });        System.out.println(finalResult.join());    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CompletableFuture&quot;&gt;&lt;a href=&quot;#CompletableFuture&quot; class=&quot;headerlink&quot; title=&quot;CompletableFuture&quot;&gt;&lt;/a&gt;CompletableFuture&lt;/h1&gt;&lt;h2 id=&quot;2-1-F</summary>
      
    
    
    
    <category term="JUC并发编程" scheme="https://gitee.com/yunyd/categories/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="JUC并发编程" scheme="https://gitee.com/yunyd/tags/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程基础知识复习-1</title>
    <link href="https://gitee.com/yunyd/posts/5e115804.html"/>
    <id>https://gitee.com/yunyd/posts/5e115804.html</id>
    <published>2023-07-26T05:12:22.000Z</published>
    <updated>2023-08-12T23:23:44.444Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程基础知识复习"><a href="#线程基础知识复习" class="headerlink" title="线程基础知识复习"></a>线程基础知识复习</h1><p>● 1把锁：synchronized（后面细讲）</p><p>● 2个并：</p><p>​            ○并发（concurrent）：是在同一实体上的多个事件，是在一台机器上“同时”处理多个任务，同一时刻，其实是只有一个事情再发生。</p><p>​            ○并行（parallel）：是在不同实体上的多个事件，是在多台处理器上同时处理多个任务，同一时刻，大家都在做事情，你做你的，我做我的，各干各的。</p><p>●3个程：</p><p>​            ○进程：在系统中运行的一个应用程序，每个进程都有它自己的内存空间和系统资源</p><p>​            ○线程：也被称为轻量级进程，在同一个进程内会有1个或多个线程，是大多数操作系统进行时序调度的基本单元。</p><p>​            ○管程：Monitor（锁），也就是我们平时所说的锁。Monitor其实是一种同步机制，它的义务是保证（同一时间）只有一个线程可以访问被保护的数据和代码，JVM中同步是基于进入和退出监视器（Monitor管程对象）来实现的，每个对象实例都会有一个Monitor对象，Monitor对象和Java对象一同创建并销毁，底层由C++语言实现。</p><p>●线程分类（一般不做特别说明配置，默认都是用户线程）：</p><p>​            ○用户线程：是系统的工作线程，它会完成这个程序需要完成的业务操作。</p><p>​            ○守护线程：是一种特殊的线程为其他线程服务的，在后台默默地完成一些系统性的任务，比如垃圾回收线程就是最典型的例子。守护线程作为一个服务线程，没有服务对象就没有必要继续运行了，如果用户线程全部结束了，意味着程序需要完成的业务操作已经结束了，系统可以退出了。所以假如当系统只剩下守护线程的时候，守护线程伴随着JVM一同结束工作。</p><p>守护线程代码实操</p><p>Java</p><p>代码</p><pre class="line-numbers language-Java" data-language="Java"><code class="language-Java">public class DaemonDemo {​    public static void main(String[] args) {​        Thread t1 = new Thread(() -&gt; {​            System.out.println(Thread.currentThread().getName() + " 开始运行," + (Thread.currentThread().isDaemon() ? "守护线程" : "用户线程"));​            while (true) {​            }​        }, "t1");​        t1.setDaemon(true);//通过设置属性Daemon来设置当前线程是否为守护线程​        t1.start();​        try {​            TimeUnit.SECONDS.sleep(3);​        } catch (InterruptedException e) {​            e.printStackTrace();​        }​        System.out.println(Thread.currentThread().getName() + " 主线程结束");​    }}输出：t1 开始运行,守护线程main 主线程结束---&gt;在main主线程结束后，守护线程会伴随着JVM一同结束工作，即使还有循环没有结束<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;线程基础知识复习&quot;&gt;&lt;a href=&quot;#线程基础知识复习&quot; class=&quot;headerlink&quot; title=&quot;线程基础知识复习&quot;&gt;&lt;/a&gt;线程基础知识复习&lt;/h1&gt;&lt;p&gt;● 1把锁：synchronized（后面细讲）&lt;/p&gt;
&lt;p&gt;● 2个并：&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="JUC并发编程" scheme="https://gitee.com/yunyd/categories/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="JUC并发编程" scheme="https://gitee.com/yunyd/tags/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux</title>
    <link href="https://gitee.com/yunyd/posts/53d0684b.html"/>
    <id>https://gitee.com/yunyd/posts/53d0684b.html</id>
    <published>2023-07-26T03:00:36.000Z</published>
    <updated>2023-08-13T11:35:58.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux基础命令"><a href="#Linux基础命令" class="headerlink" title="Linux基础命令"></a>Linux基础命令</h1><h2 id="Linux的目录结构"><a href="#Linux的目录结构" class="headerlink" title="Linux的目录结构"></a>Linux的目录结构</h2><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/Linux/1.png"></p><ul><li><code>/</code>，根目录是最顶级的目录了</li><li>Linux只有一个顶级目录：<code>/</code></li><li>路径描述的层次关系同样适用<code>/</code>来表示</li><li>/home/itheima/a.txt，表示根目录下的home文件夹内有itheima文件夹，内有a.txt</li></ul><h2 id="开放端口"><a href="#开放端口" class="headerlink" title="开放端口"></a>开放端口</h2><ul><li>开放80端口 firewall-cmd –zone=public –add-port=80/tcp –permanent  </li><li>重启firewall    firewall-cmd –reload  </li><li>查看开放的端口   firewall-cmd –list-ports  </li></ul><h2 id="返回刚才的目录"><a href="#返回刚才的目录" class="headerlink" title="返回刚才的目录"></a>返回刚才的目录</h2><ul><li>cd -</li></ul><h2 id="图形化界面与命令行模式的切换"><a href="#图形化界面与命令行模式的切换" class="headerlink" title="图形化界面与命令行模式的切换"></a>图形化界面与命令行模式的切换</h2><ul><li>systemctl set-default graphical.target //设置开机启动自动由命令行模式更改为图形界面模式</li><li>systemctl set-default multi-user.target //设置开机启动自动由图形界面模式更改为命令行模式</li><li>init 0  //关机</li><li>init 3  //由图形化界面切换到命令行界面</li><li>init 5  //由命令行界面切换到图形化界面</li><li>init 6 或 reboot //重启</li></ul><h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><ul><li>systemctl status firewalld  查看当前防火墙状态</li><li>systemctl stop firewalld.service   关闭防火墙</li><li>systemctl disable firewalld.service  禁止开机自启防火墙</li><li>systemctl start firewalld.service  打开防火墙</li></ul><h2 id="Linux命令行上面查看命令的用法"><a href="#Linux命令行上面查看命令的用法" class="headerlink" title="Linux命令行上面查看命令的用法"></a>Linux命令行上面查看命令的用法</h2><p>命令  –help</p><h2 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h2><p>功能：列出文件夹信息</p><p>语法：<code>ls [-l -h -a] [参数]</code></p><ul><li>参数：被查看的文件夹，不提供参数，表示查看当前工作目录</li><li>-l，以列表形式查看</li><li>-h，配合-l，以更加人性化的方式显示文件大小</li><li>-a，显示隐藏文件</li></ul><h3 id="隐藏文件、文件夹"><a href="#隐藏文件、文件夹" class="headerlink" title="隐藏文件、文件夹"></a>隐藏文件、文件夹</h3><p>在Linux中以<code>.</code>开头的，均是隐藏的。</p><p>默认不显示出来，需要<code>-a</code>选项才可查看到。</p><h2 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h2><p>功能：展示当前工作目录</p><p>语法：<code>pwd</code></p><h2 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h2><p>功能：切换工作目录</p><p>语法：<code>cd [目标目录]</code></p><p>参数：目标目录，要切换去的地方，不提供默认切换到<code>当前登录用户HOME目录</code></p><h2 id="HOME目录"><a href="#HOME目录" class="headerlink" title="HOME目录"></a>HOME目录</h2><p>每一个用户在Linux系统中都有自己的专属工作目录，称之为HOME目录。</p><ul><li><p>普通用户的HOME目录，默认在：<code>/home/用户名</code></p></li><li><p>root用户的HOME目录，在：<code>/root</code></p></li></ul><p>FinalShell登陆终端后，默认的工作目录就是用户的HOME目录</p><h2 id="相对路径、绝对路径"><a href="#相对路径、绝对路径" class="headerlink" title="相对路径、绝对路径"></a>相对路径、绝对路径</h2><ul><li><p>相对路径，==非==<code>/</code>开头的称之为相对路径</p><p>相对路径表示以<code>当前目录</code>作为起点，去描述路径，如<code>test/a.txt</code>，表示当前工作目录内的test文件夹内的a.txt文件</p></li><li><p>绝对路径，==以==<code>/</code>开头的称之为绝对路径</p><p>绝对路径从<code>根</code>开始描述路径</p></li></ul><h2 id="特殊路径符"><a href="#特殊路径符" class="headerlink" title="特殊路径符"></a>特殊路径符</h2><ul><li><code>.</code>，表示当前，比如./a.txt，表示当前文件夹内的<code>a.txt</code>文件</li><li><code>..</code>，表示上级目录，比如<code>../</code>表示上级目录，<code>../../</code>表示上级的上级目录</li><li><code>~</code>，表示用户的HOME目录，比如<code>cd ~</code>，即可切回用户HOME目录</li></ul><h2 id="nohup命令"><a href="#nohup命令" class="headerlink" title="nohup命令"></a>nohup命令</h2><p>英文全称：no hang up（不挂起），用于不挂断地运行指定命令，退出终端不会影响程序的运行；</p><p>语法格式：nohup Command [Arg …] [&amp;]</p><p>参数说明：</p><p>Command：要执行的命令</p><p>Arg：一些参数，可以指定输出文件</p><p>&amp;：让命令在后台运行</p><p>举例：</p><p>nohup java -jar boot工程.jar &amp;&gt; hello.log &amp;                     后台运行java -jar命令，并将日志输出到hello.log文件,hello.log文件会在当前目录下面生成</p><h2 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h2><p>功能：创建文件夹</p><p>语法：<code>mkdir [-p] 参数</code></p><ul><li><p>参数：被创建文件夹的路径（相对、绝对、特殊路径符都可以使用）</p><p>mkdir /home/test</p><p>mkdir test01</p></li><li><p>选项：-p，可选，表示创建前置路径（表示自动创建不存在的父目录，适用于创建连续多层级的目录）</p><p>mkdir -p itliu/good/666（如果不用-p的话，会报错，因为没有itliu和good的文件夹）</p></li></ul><p>注意：如果是普通用户的话，创建文件夹需要修改权限，只能在HOME目录内才可以创建文件夹，在HOME目录外创建文件夹需要权限，root用户才可以</p><h2 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h2><p>功能：创建文件</p><p>语法：<code>touch 参数</code></p><p>touch test</p><ul><li>参数：被创建的文件路径（相对、绝对、特殊路径符都可以使用）</li></ul><h2 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h2><p>功能：查看文件内容</p><p>语法：<code>cat 参数</code></p><ul><li>参数：被查看的文件路径（相对、绝对、特殊路径符都可以使用）</li></ul><h2 id="more命令"><a href="#more命令" class="headerlink" title="more命令"></a>more命令</h2><p>功能：查看文件，可以支持翻页查看</p><p>语法：<code>more 参数</code></p><ul><li>参数：被查看的文件路径（相对、绝对、特殊路径符都可以使用）</li><li>在查看过程中：<ul><li><code>空格</code>键翻页</li><li><code>q</code>退出查看</li></ul></li></ul><h2 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h2><p>功能：复制文件、文件夹</p><p>语法：<code>cp [-r] 参数1 参数2</code></p><ul><li>参数1，被复制的</li><li>参数2，要复制去的地方</li><li>选项：-r，可选，复制文件夹使用</li></ul><p>示例：</p><ul><li>cp a.txt b.txt，复制当前目录下a.txt为b.txt</li><li>cp a.txt test/，复制当前目录a.txt到test文件夹内</li><li>cp -r test test2，复制文件夹test及test下面的所有文件到当前文件夹内为test2存在</li><li>cp -r test/. test2  表示将test下的文件复制到test2,不包括test目录</li></ul><h2 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h2><p>功能：移动文件、文件夹</p><p>语法：<code>mv 参数1 参数2</code></p><ul><li><p>参数1：Linux路径，被移动的文件或者文件夹</p></li><li><p>参数2：Linux路径，要移动去的地方，参数2如果不存在，则会进行改名</p><p>mv test01.txt test02.txt(将test01.txt改名为test02.txt)</p></li></ul><h2 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h2><p>功能：删除文件、文件夹</p><p>语法：<code>rm [-r -f] 参数1 参数2....参数N</code></p><ul><li>参数：支持多个，每一个表示被删除的，空格进行分隔(可以用绝对，相对，特殊路径)（/root/test）</li><li>选项：-r，删除文件夹使用</li><li>选项：-f，强制删除，不会给出确认提示，一般root用户会用到</li></ul><p>rm命令支持通配符*，用来做模糊匹配</p><ul><li>符号*表示通配符， 即匹配任意内容（包含空），示例：</li><li>test*，表示匹配任何以test开头 的内容</li><li>*test，表示匹配任何以test结尾的内容</li><li>*test *，表示匹配任何包含test的内容</li></ul><blockquote><p>rm命令很危险，一定要注意，特别是切换到root用户的时候。</p></blockquote><h2 id="which命令"><a href="#which命令" class="headerlink" title="which命令"></a>which命令</h2><p>功能：查看命令的程序本体文件路径，前面学习的Linux命令，其实它们的本体就是一个个的二进制可执行程序，和Windows系统中的.exe文件，是一个意思。可以通过which命令，查看所使用的一系列命令的程序文件存放在哪里</p><p>语法：<code>which 参数</code></p><ul><li><p>参数：被查看的命令</p><p>例：</p><p>[itliu@bogon ~]which cd</p><p>/usr/bin/cd</p><p>[itliu@bogon ~]which pwd</p><p>/usr/bin/pwd</p></li></ul><h2 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h2><p>功能：按名称搜索文件</p><p>语法1按文件名搜索：<code>find 路径 -name 参数(“被查找的文件名或者目录”)</code></p><ul><li>路径，搜索的起始路径</li><li>参数，搜索的关键字，支持通配符*， 比如：<code>*</code>test表示搜索任意以test结尾的文件</li></ul><p>功能：按文件大小查找文件</p><p>语法：find 其实路径 -size +|-n[kMG]</p><ul><li>+、-表示大于和小于</li><li>n表示大小数字</li><li>kMG表示大单位，k（小写字母）表示kb，M表示MB，G表示GB</li></ul><p>示例：</p><ul><li>查找小于10KB的文件：find / -size -10k</li><li>查找大于100MB的文件: find /-size +100M</li><li>查找大于1GB的文件: fing / -size +1G</li></ul><h2 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h2><p>功能：过滤关键字</p><p>语法：<code>grep [-n] 关键字 文件路径</code></p><ul><li>选项-n，可选，表示在结果中显示匹配的行的行号。</li><li>参数，关键字，必填，表示过滤的关键字，带有空格或其它特殊符号，建议使用””将关键字包围起来</li><li>参数，文件路径，必填，表示要过滤内容的文件路径，可作为内容输入端口</li></ul><p>grep “itheima” test.txt</p><p>grep -n “itheima” test.txt</p><blockquote><p>参数文件路径，可以作为管道符的输入</p></blockquote><h2 id="wc命令"><a href="#wc命令" class="headerlink" title="wc命令"></a>wc命令</h2><p>功能：统计</p><p>语法：<code>wc [-c -m -l -w] 文件路径</code></p><ul><li>选项，-c，统计bytes数量</li><li>选项，-m，统计字符数量</li><li>选项，-l，统计行数</li><li>选项，-w，统计单词数量</li><li>参数，文件路径，被统计的文件，可作为内容输入端口</li></ul><p>wc test.txt</p><blockquote><p>参数文件路径，可作为管道符的输入</p></blockquote><h2 id="管道符"><a href="#管道符" class="headerlink" title="管道符|"></a>管道符|</h2><p>写法：<code>|</code></p><p>功能：将符号左边命令的结果，作为符号右边命令的输入</p><p>示例：</p><p><code>cat a.txt | grep itheima</code>，将cat a.txt的结果，作为grep命令的输入，用来过滤<code>itheima</code>关键字</p><p>cat a.txt | grep itheima  等同于  grep itheima a.txt</p><p>cat a.txt | wc -l    等同于    wc -l a.txt</p><p>可以支持嵌套：</p><p><code>cat a.txt | grep itheima | grep itcast</code></p><p>执行流程：首先cat a.txt | grep itheima ，然后将cat a.txt | grep itheima的结果作为grep itcast命令的输入</p><p>管道符左边的命令不一定只能是cat，只要是能产生内容输出的命令，都可以跟管道符做配合。比如ls命令，也有输出</p><p>例如：</p><ul><li>ls | grep test      这样就可以在当前目录里面的所有文件夹过滤出test的文件夹</li><li>ls /usr/bin | grep gtf         可以在/usr/bin目录下面，只输出gtf，过滤掉出gtf外所有的文件</li><li>ls -l /usr/bin | grep gtf </li><li>ls -l /usr/bin | wc -l            统计出/usr/bin目录下面共计多少行</li></ul><h2 id="echo命令"><a href="#echo命令" class="headerlink" title="echo命令"></a>echo命令</h2><p>功能：输出内容</p><p>语法：<code>echo 参数</code></p><ul><li>参数：被输出的内容,带有空格或者\等特殊符号，建议使用双引号包围（因为不包围的话，空格后很容易被识别为参数2，尽管</li></ul><p>echo不受影响，但是要养成习惯</p><p>echo “Hello World”</p><h2 id="反引号"><a href="#反引号" class="headerlink" title="`反引号"></a>`反引号</h2><p>功能：被两个反引号包围的内容，会作为命令执行</p><p>``这个符号位于Esc下面与~符号在一起</p><p>示例：</p><ul><li>echo `pwd`，会输出当前工作目录</li></ul><h2 id="重定向符"><a href="#重定向符" class="headerlink" title="重定向符"></a>重定向符</h2><ul><li><code>&gt;</code>,将左侧命令的结果，覆盖写入到符号右侧指定的文件中</li><li><code>&gt;&gt;</code>,将左侧命令的结果，追加写入到符号右侧指定的文件中</li></ul><p>演示：</p><ul><li><p>先执行echo “Hello Linux” &gt; itheima.txt</p></li><li><p>再执行echo “Hello itheima” &gt;itheima.txt，覆盖新内容</p></li><li><p>再次执行echo “Hello itcast” &gt;&gt; itheima.txt，使用&gt;&gt;追加新内容</p></li></ul><p><code>&gt;</code>和<code>&gt;&gt;</code>的使用，只要是左面产生结果的，可以将符号左面命令的结果，直接覆盖或追加到右面的文件中</p><h2 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h2><p>功能：查看文件尾部内容</p><p>语法：<code>tail [-f -num] 参数</code></p><ul><li>参数：Linux路径，表示被查看的文件</li><li>选项：-f，持续跟踪文件修改</li><li>选项: -num,表示查看尾部多少行，不填默认10行</li></ul><p>tail test.txt(默认查看尾部10的内容)</p><p>tail -5 test.txt(查看尾部5行的内容)</p><p>tail -f test.txt(默认查看尾部10行的内容，并且程序继续运行，此时对当前finalshell右键，复制一个标签，相当于新连接一个窗口，在那个窗口继续使用命令例如：echo “hello dajiahao” &gt;&gt; test.txt,这个命令执行完毕后，此时再打开之前那个标签窗口，会新显示你刚写的内容)如果想停止的话直接ctrl+c</p><h2 id="head命令"><a href="#head命令" class="headerlink" title="head命令"></a>head命令</h2><p>功能：查看文件头部内容</p><p>语法：<code>head [-n] 参数</code></p><ul><li>参数：被查看的文件</li><li>选项：-n，查看的行数</li></ul><h2 id="vi编辑器"><a href="#vi编辑器" class="headerlink" title="vi编辑器"></a>vi编辑器</h2><h3 id="命令模式快捷键"><a href="#命令模式快捷键" class="headerlink" title="命令模式快捷键"></a>命令模式快捷键</h3><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/Linux/2.png"></p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/Linux/3.png"></p><p>退出搜索模式：noh</p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/Linux/4.png"></p><h3 id="底线命令快捷键"><a href="#底线命令快捷键" class="headerlink" title="底线命令快捷键"></a>底线命令快捷键</h3><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/Linux/5.png"></p><h2 id="命令的选项"><a href="#命令的选项" class="headerlink" title="命令的选项"></a>命令的选项</h2><p>我们学习的一系列Linux命令，它们所拥有的选项都是非常多的。</p><p>比如，简单的ls命令就有：-a -A -b -c -C -d -D -f -F -g -G -h -H -i -I -k -l -L -m -n -N -o -p -q -Q -r-R -s -S -t -T -u -U -v -w -x -X -1等选项，可以发现选项是极其多的。</p><p>课程中， 并不会将全部的选项都进行讲解，否则，一个ls命令就可能讲解2小时之久。</p><p>课程中，会对常见的选项进行讲解， 足够满足绝大多数的学习、工作场景。</p><h3 id="查看命令的帮助"><a href="#查看命令的帮助" class="headerlink" title="查看命令的帮助"></a>查看命令的帮助</h3><p>可以通过：<code>命令 --help</code>查看命令的帮助手册</p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/Linux/6.png"></p><h3 id="查看命令的详细手册"><a href="#查看命令的详细手册" class="headerlink" title="查看命令的详细手册"></a>查看命令的详细手册</h3><p>可以通过：<code>man 命令</code>查看某命令的详细手册</p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/Linux/7.png"></p><h1 id="Linux常用操作"><a href="#Linux常用操作" class="headerlink" title="Linux常用操作"></a>Linux常用操作</h1><h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><ul><li>CentOS系统使用：<ul><li>yum [install remove search] [-y] 软件名称<ul><li>install 安装</li><li>remove 卸载</li><li>search 搜索</li><li>-y，自动确认</li></ul></li></ul></li><li>Ubuntu系统使用<ul><li>apt [install remove search] [-y] 软件名称<ul><li>install 安装</li><li>remove 卸载</li><li>search 搜索</li><li>-y，自动确认</li></ul></li></ul></li></ul><blockquote><p>yum 和 apt 均需要root权限</p></blockquote><h2 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h2><p>功能：控制系统服务的启动关闭等</p><p>语法：<code>systemctl start | stop | restart | disable | enable | status 服务名</code></p><ul><li>start，启动</li><li>stop，停止</li><li>status，查看状态</li><li>disable，关闭开机自启</li><li>enable，开启开机自启</li><li>restart，重启</li></ul><h2 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h2><p>功能：创建文件、文件夹软链接（快捷方式）</p><p>语法：<code>ln -s 参数1 参数2</code></p><ul><li>参数1：被链接的（需要使用绝对路径）</li><li>参数2：要链接去的地方（快捷方式的名称和存放位置）</li></ul><h2 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h2><p>语法：<code>date [-d] [+格式化字符串]</code></p><ul><li><p>-d 按照给定的字符串显示日期，一般用于日期计算</p></li><li><p>格式化字符串：通过特定的字符串标记，来控制显示的日期格式</p><ul><li>%Y   年%y   年份后两位数字 (00..99)</li><li>%m   月份 (01..12)</li><li>%d   日 (01..31)</li><li>%H   小时 (00..23)</li><li>%M   分钟 (00..59)</li><li>%S   秒 (00..60)</li><li>%s   自 1970-01-01 00:00:00 UTC 到现在的秒数</li></ul></li></ul><p>示例：</p><ul><li><p>按照2022-01-01的格式显示日期</p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/Linux/8.png"></p></li><li><p>按照2022-01-01 10:00:00的格式显示日期</p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/Linux/9.png"></p></li><li><p>-d选项日期计算</p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/Linux/10.png"></p><ul><li><p>支持的时间标记为：</p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/Linux/11.png"></p></li></ul></li></ul><h2 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h2><p>修改时区为中国时区</p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/Linux/12.png"></p><h2 id="ntp"><a href="#ntp" class="headerlink" title="ntp"></a>ntp</h2><p>功能：同步时间</p><p>安装：<code>yum install -y ntp</code></p><p>启动管理：<code>systemctl start | stop | restart | status | disable | enable ntpd</code></p><p>手动校准时间：<code>ntpdate -u ntp.aliyun.com</code></p><h2 id="ip地址"><a href="#ip地址" class="headerlink" title="ip地址"></a>ip地址</h2><p>格式：a.b.c.d</p><ul><li>abcd为0~255的数字</li></ul><p>特殊IP：</p><ul><li>127.0.0.1，表示本机</li><li>0.0.0.0<ul><li>可以表示本机</li><li>也可以表示任意IP（看使用场景）</li></ul></li></ul><p>查看ip：<code>ifconfig</code></p><h2 id="主机名"><a href="#主机名" class="headerlink" title="主机名"></a>主机名</h2><p>功能：Linux系统的名称</p><p>查看：<code>hostname</code></p><p>设置：<code>hostnamectl set-hostname 主机名</code></p><h2 id="配置VMware固定IP"><a href="#配置VMware固定IP" class="headerlink" title="配置VMware固定IP"></a>配置VMware固定IP</h2><ol><li><p>修改VMware网络，参阅PPT，图太多</p></li><li><p>设置Linux内部固定IP</p><p>修改文件：<code>/etc/sysconfig/network-scripts/ifcfg-ens33</code></p><p>示例文件内容：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">TYPE</span><span class="token operator">=</span><span class="token string">"Ethernet"</span><span class="token assign-left variable">PROXY_METHOD</span><span class="token operator">=</span><span class="token string">"none"</span><span class="token assign-left variable">BROWSER_ONLY</span><span class="token operator">=</span><span class="token string">"no"</span><span class="token assign-left variable">BOOTPROTO</span><span class="token operator">=</span><span class="token string">"static"</span><span class="token comment"># 改为static，固定IP</span><span class="token assign-left variable">DEFROUTE</span><span class="token operator">=</span><span class="token string">"yes"</span><span class="token assign-left variable">IPV4_FAILURE_FATAL</span><span class="token operator">=</span><span class="token string">"no"</span><span class="token assign-left variable">IPV6INIT</span><span class="token operator">=</span><span class="token string">"yes"</span><span class="token assign-left variable">IPV6_AUTOCONF</span><span class="token operator">=</span><span class="token string">"yes"</span><span class="token assign-left variable">IPV6_DEFROUTE</span><span class="token operator">=</span><span class="token string">"yes"</span><span class="token assign-left variable">IPV6_FAILURE_FATAL</span><span class="token operator">=</span><span class="token string">"no"</span><span class="token assign-left variable">IPV6_ADDR_GEN_MODE</span><span class="token operator">=</span><span class="token string">"stable-privacy"</span><span class="token assign-left variable">NAME</span><span class="token operator">=</span><span class="token string">"ens33"</span><span class="token assign-left variable">UUID</span><span class="token operator">=</span><span class="token string">"1b0011cb-0d2e-4eaa-8a11-af7d50ebc876"</span><span class="token assign-left variable">DEVICE</span><span class="token operator">=</span><span class="token string">"ens33"</span><span class="token assign-left variable">ONBOOT</span><span class="token operator">=</span><span class="token string">"yes"</span><span class="token assign-left variable">IPADDR</span><span class="token operator">=</span><span class="token string">"192.168.88.131"</span><span class="token comment"># IP地址，自己设置，要匹配网络范围</span><span class="token assign-left variable">NETMASK</span><span class="token operator">=</span><span class="token string">"255.255.255.0"</span><span class="token comment"># 子网掩码，固定写法255.255.255.0</span><span class="token assign-left variable">GATEWAY</span><span class="token operator">=</span><span class="token string">"192.168.88.2"</span><span class="token comment"># 网关，要和VMware中配置的一致</span><span class="token assign-left variable">DNS1</span><span class="token operator">=</span><span class="token string">"192.168.88.2"</span><span class="token comment"># DNS1服务器，和网关一致即可</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h2><p>功能：查看进程信息</p><p>语法：<code>ps -ef</code>，查看全部进程信息，可以搭配grep做过滤：<code>ps -ef | grep xxx</code></p><h2 id="kill命令"><a href="#kill命令" class="headerlink" title="kill命令"></a>kill命令</h2><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/Linux/13.png"></p><h2 id="nmap命令"><a href="#nmap命令" class="headerlink" title="nmap命令"></a>nmap命令</h2><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/Linux/14.png"></p><h2 id="netstat命令"><a href="#netstat命令" class="headerlink" title="netstat命令"></a>netstat命令</h2><p>功能：查看端口占用，或者进程占用哪个端口</p><p>用法：<code>netstat -anp | grep xxx</code></p><ul><li>netstat -anp | grep 12345  (如果命令执行完毕后，没有任何结果，就说明没有12345这个进程，并且12345这个端口也没有人占用)</li></ul><h2 id="ping命令"><a href="#ping命令" class="headerlink" title="ping命令"></a>ping命令</h2><p>测试网络是否联通</p><p>语法：<code>ping [-c num] 参数</code></p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/Linux/15.png"></p><h2 id="wget命令"><a href="#wget命令" class="headerlink" title="wget命令"></a>wget命令</h2><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/Linux/16.png"></p><h2 id="curl命令"><a href="#curl命令" class="headerlink" title="curl命令"></a>curl命令</h2><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/Linux/17.png"></p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/Linux/18.png"></p><h2 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h2><p>功能：查看主机运行状态</p><p>语法：<code>top</code>，查看基础信息</p><p>可用选项：</p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/Linux/19.png"></p><p>交互式模式中，可用快捷键：</p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/Linux/20.png"></p><h2 id="df命令"><a href="#df命令" class="headerlink" title="df命令"></a>df命令</h2><p>查看磁盘占用</p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/Linux/21.png"></p><h2 id="iostat命令"><a href="#iostat命令" class="headerlink" title="iostat命令"></a>iostat命令</h2><p>查看CPU、磁盘的相关信息</p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/Linux/22.png"></p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/Linux/23.png"></p><h2 id="sar命令"><a href="#sar命令" class="headerlink" title="sar命令"></a>sar命令</h2><p>查看网络统计</p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/Linux/24.png"></p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><ul><li>临时设置：export 变量名=变量值</li><li>永久设置：<ul><li>针对用户，设置用户HOME目录内：<code>.bashrc</code>文件</li><li>针对全局，设置<code>/etc/profile</code></li></ul></li></ul><h3 id="PATH变量"><a href="#PATH变量" class="headerlink" title="PATH变量"></a>PATH变量</h3><p>记录了执行程序的搜索路径</p><p>可以将自定义路径加入PATH内，实现自定义命令在任意地方均可执行的效果</p><h2 id="符号"><a href="#符号" class="headerlink" title="$符号"></a>$符号</h2><p>可以取出指定的环境变量的值</p><p>语法：<code>$变量名</code></p><p>示例：</p><p><code>echo $PATH</code>，输出PATH环境变量的值</p><p><code>echo ${PATH}ABC</code>，输出PATH环境变量的值以及ABC</p><p>如果变量名和其它内容混淆在一起，可以使用${}</p><h2 id="rz、sz命令"><a href="#rz、sz命令" class="headerlink" title="rz、sz命令"></a>rz、sz命令</h2><p>rz、sz命令需要安装。可以通过：yum -y install lrzsz，即可安装</p><ul><li>rz命令，进行上传，语法：直接输入rz即可</li><li></li><li>sz命令进行下载，语法：sz 要下载的文件<ul><li>文件会自动下载到桌面的fsdownload文件夹中</li></ul></li></ul><h2 id="压缩解压"><a href="#压缩解压" class="headerlink" title="压缩解压"></a>压缩解压</h2><p>Linux和Mac系统常用有2种压缩格式，后缀名分别是：</p><ul><li>.tar  称之为tarball，归档文件，即简单的将文件组装到一个.tar的文件内，并没有太多文件体积的减少，仅仅是简单的封装</li><li>.gz，也常见为.tar.gz，gzip格式压缩文件，即使用gzip压缩算法将文件解压到一个文件内，可以极大地减少压缩后的体积</li><li>针对这两种格式，使用tar命令均可以进行压缩和解压缩的操作</li></ul><p>语法： tar [-c -v -x- f- z- C] 参数1 参数2 …  参数N</p><ul><li> -c，创建压缩文件，用于压缩模式</li><li> -v，显示压缩、解压过程，用于查看进度</li><li> -x，解压模式</li><li> -f，要创建的文件，或要解压的文件，-f选项必须在所有选项中位置处于最后一个</li><li> -z，gzip模式，不使用-z就是普通的tarball格式</li><li> -C，选择解压的目的地，用于解压模式</li></ul><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p><code>tar -zcvf 压缩包 被压缩1...被压缩2...被压缩N</code></p><ul><li>-z表示使用gzip，可以不写<ul><li>tar -cvf test.tar 1.txt 2.txt 3.txt<ul><li>将1.txt 2.txt 3.txt压缩到test.tar文件内</li></ul></li><li>tar -zcvf test.tar 1.txt 2.txt 3.txt<ul><li>将1.txt 2.txt 3.txt压缩到test.tar.gz文件内,使用gzip模式</li></ul></li></ul></li></ul><p><code>zip [-r] 参数1 参数2 参数N</code></p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/Linux/25.png"></p><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><p><code>tar -zxvf 被解压的文件 -C 要解压去的地方</code></p><ul><li>-z表示使用gzip，可以省略</li><li>-C，可以省略，指定要解压去的地方，不写解压到当前目录</li></ul><p><code>unzip [-d] 参数</code></p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/Linux/26.png"></p><h2 id="su命令"><a href="#su命令" class="headerlink" title="su命令"></a>su命令</h2><p>切换用户</p><p>语法：<code>su [-] [用户]</code></p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/Linux/27.png"></p><h2 id="sudo命令"><a href="#sudo命令" class="headerlink" title="sudo命令"></a>sudo命令</h2><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/Linux/28.png"></p><p>比如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">itheima <span class="token assign-left variable">ALL</span><span class="token operator">=</span><span class="token punctuation">(</span>ALL<span class="token punctuation">)</span>       NOPASSWD: ALL<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在visudo内配置如上内容，可以让itheima用户，无需密码直接使用<code>sudo</code></p><h2 id="查看权限控制信息"><a href="#查看权限控制信息" class="headerlink" title="查看权限控制信息"></a>查看权限控制信息</h2><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/Linux/29.png"></p><ul><li>序号1，表示文件、文件夹的权限控制信息</li><li>序号2，表示文件、文件夹所属用户</li><li>序号3，表示文件、文件夹所属用户组</li></ul><p>权限信息共十位</p><ol><li>第1位<ul><li>第二位内容（-或d或l）</li><li>-表示文件</li><li>d表示文件夹</li><li>l表示软链接</li></ul></li><li>第2-4位<ul><li>第2位内容（r或-）</li><li>第3位内容（w或-）</li><li>第4位内容（x或-）</li><li>-表示无此权限</li></ul></li><li>第5-7位<ul><li>第5位内容（r或-）</li><li>第6位内容（w或-）</li><li>第7位内容（x或-）</li><li>-表示无此权限</li></ul></li><li>第8-10位<ul><li>第8位内容（r或-）</li><li>第9位内容（w或-）</li><li>第10位内容（x或-）</li><li>-表示无此权限</li></ul></li></ol><h5 id="rwx分别代表什么"><a href="#rwx分别代表什么" class="headerlink" title="rwx分别代表什么"></a>rwx分别代表什么</h5><ul><li>r,针对文件可以查看文件内容<ul><li>针对文件夹，可以查看文件夹内容，如ls命令</li></ul></li><li>w，针对文件表示可以修改此文件<ul><li>针对文件夹，可以在文件夹内：创建、删除、改名等操作</li></ul></li><li>x，针对文件表示可以将文件作为程序执行<ul><li>针对文件夹，表示可以更改目录到此文件夹，即cd进入</li></ul></li></ul><h2 id="chmod命令"><a href="#chmod命令" class="headerlink" title="chmod命令"></a>chmod命令</h2><p>修改文件、文件夹权限</p><p>语法：<code>chmod [-R] 权限 参数</code></p><ul><li><p>权限，要设置的权限，比如755，表示：<code>rwxr-xr-x</code></p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/Linux/30.png"></p></li><li><p>参数，被修改的文件、文件夹</p></li><li><p>选项-R，设置文件夹和其内部全部内容一样生效</p></li><li><p>chmod u=rwx,g=rx,o=x hello.txt，将文件权限修改为：rwxr-x–x</p><ul><li>其中：u表示user所属用户权限，g表示group组权限，o表示other其它用户权限</li></ul></li><li><p>chmod-R u=rwx，g=rx,o=x test，将文件夹test以及文件夹内全部内容权限设置为:rwxr-x–x</p></li></ul><h2 id="chown命令"><a href="#chown命令" class="headerlink" title="chown命令"></a>chown命令</h2><p>修改文件、文件夹所属用户、组</p><p>语法：<code>chown [-R] [用户][:][用户组] 文件或文件夹</code></p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/Linux/31.png"></p><h2 id="用户组管理"><a href="#用户组管理" class="headerlink" title="用户组管理"></a>用户组管理</h2><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/Linux/32.png"></p><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/Linux/33.png"></p><h2 id="getent命令"><a href="#getent命令" class="headerlink" title="getent命令"></a>getent命令</h2><ul><li><p><code>getent group</code>，查看系统全部的用户组</p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/Linux/34.png"></p></li><li><p><code>getent passwd</code>，查看系统全部的用户</p><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/Linux/35.png"></p></li></ul><h2 id="env命令"><a href="#env命令" class="headerlink" title="env命令"></a>env命令</h2><p>查看系统全部的环境变量</p><p>语法：<code>env</code></p><h2 id="常用快捷命令"><a href="#常用快捷命令" class="headerlink" title="常用快捷命令"></a>常用快捷命令</h2><ol><li>ctrl + c 强制退出</li><li>ctrl + d 退出或登出  （不能用于vi/vim）</li><li>history查看历史输入过的命令<ul><li>history | grep ls  （过滤出历史输入过的ls命令）</li></ul></li><li>ctrl + r   输入内容去匹配历史命令<ul><li>如果搜索到的内容是你需要的，那么：<ul><li>回车键可以直接执行</li><li>键盘左键或者右键，可以得到此命令（不执行）</li></ul></li></ul></li><li>光标移动快捷键<ul><li>ctrl + a 跳到命令开头</li><li>ctrl + e 跳到命令结尾</li><li>ctrl + 键盘左键，向左跳一个单词</li><li>ctrl + 键盘右键，向右跳一个单词</li></ul></li><li>清屏<ul><li>通过快捷键ctrl + l 可以清空终端内容</li><li>或通过命令clear得到同样的效果</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux基础命令&quot;&gt;&lt;a href=&quot;#Linux基础命令&quot; class=&quot;headerlink&quot; title=&quot;Linux基础命令&quot;&gt;&lt;/a&gt;Linux基础命令&lt;/h1&gt;&lt;h2 id=&quot;Linux的目录结构&quot;&gt;&lt;a href=&quot;#Linux的目录结构&quot; cla</summary>
      
    
    
    
    <category term="Linux" scheme="https://gitee.com/yunyd/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://gitee.com/yunyd/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>大家好</title>
    <link href="https://gitee.com/yunyd/posts/42adfbca.html"/>
    <id>https://gitee.com/yunyd/posts/42adfbca.html</id>
    <published>2023-07-21T01:01:22.000Z</published>
    <updated>2023-08-12T06:47:21.957Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大家好"><a href="#大家好" class="headerlink" title="大家好"></a>大家好</h1><h5 id="在Hexo部署时会默认渲染source下的所有html页面，但有时候想在Hexo博客上单独自定义html页面或README-md时，却不希望被Hexo渲染。"><a href="#在Hexo部署时会默认渲染source下的所有html页面，但有时候想在Hexo博客上单独自定义html页面或README-md时，却不希望被Hexo渲染。" class="headerlink" title="在Hexo部署时会默认渲染source下的所有html页面，但有时候想在Hexo博客上单独自定义html页面或README.md时，却不希望被Hexo渲染。"></a>在Hexo部署时会默认渲染source下的所有html页面，但有时候想在Hexo博客上单独自定义html页面或README.md时，却不希望被Hexo渲染。</h5><h2 id="大家好-1"><a href="#大家好-1" class="headerlink" title="大家好"></a>大家好</h2><h3 id="大家好-2"><a href="#大家好-2" class="headerlink" title="大家好"></a>大家好</h3><h4 id="大家好-3"><a href="#大家好-3" class="headerlink" title="大家好"></a>大家好</h4><h5 id="大家好-4"><a href="#大家好-4" class="headerlink" title="大家好"></a>大家好</h5><h6 id="大家好-5"><a href="#大家好-5" class="headerlink" title="大家好"></a>大家好</h6><p><img src="https://llllz-1319101047.cos.ap-beijing.myqcloud.com/img/penguin.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;大家好&quot;&gt;&lt;a href=&quot;#大家好&quot; class=&quot;headerlink&quot; title=&quot;大家好&quot;&gt;&lt;/a&gt;大家好&lt;/h1&gt;&lt;h5 id=&quot;在Hexo部署时会默认渲染source下的所有html页面，但有时候想在Hexo博客上单独自定义html页面或README</summary>
      
    
    
    
    <category term="打招呼" scheme="https://gitee.com/yunyd/categories/%E6%89%93%E6%8B%9B%E5%91%BC/"/>
    
    
    <category term="介绍" scheme="https://gitee.com/yunyd/tags/%E4%BB%8B%E7%BB%8D/"/>
    
  </entry>
  
  <entry>
    <title>第一篇博客</title>
    <link href="https://gitee.com/yunyd/posts/ff05b5bf.html"/>
    <id>https://gitee.com/yunyd/posts/ff05b5bf.html</id>
    <published>2023-07-20T00:01:13.000Z</published>
    <updated>2023-08-07T06:28:58.432Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="0d121107f181ed1cad61e06d5e131895bb464c10cb5b841740cd01fd3c06441a">165d50f05814027fb7fe5e4ae8a088d8cabf1ea2d88ccf0f53dc7b0b289f3333ce426d2290f122e350413bfc7c4b15270e1fa98bc3bdc0696bd1240dc2c54dc46f3cf8c90ee47863eda5ed8429988339008fe8f5da23a188c09fa3923cb7e84998d48f9d1db1884ecbf116f84c604df665cf1ed02440e3704fe8a1d3f4e355c4b881361cca31a753bd765fa261f4fb2636246c3e4625086b6d615ef4b2b6cd7a8f7c3280fcde1606e2b11f9b2135665ec1dd4fcf4f0ac1fcec56cc7c1f658ec6aebb9907cf5d1591950e5dcce46b7fbd70731a8c4cffc0d39deeae4a2fb58528c5e81756ffe4712f213da309241d1aef28ba26ef9771379de4137e2769df892eb6f9e10addcd0fa5290221487d6f9c4ce779be7b4c93832fbafc4e24b9e19dc48d875959cc0d44882851087bbbf9ebf47ff801dd21fe86b5b163aded09e38674606d130c35d1282dd481ba8477ead8b5fe58554f7ab87cb1bb77dcc23b874f3cbb1b9b236314dca583053c6c88a4211ac414f48a8bc8fc5175a98fea8c154655eac039a57040f78e924f6934f017cfea4e51a606e4620c6167c0b11638ee7827df798e806b80e806a2172b934c402ec5321f359ab72862c0604ee573a74db3716c358c96257842b8490322aa106b2da92da99fa9d4c37575994d8f4d82190d29b354486955e1c3eaf860c07b768fc4796b0d362e96ff45801f81faa5b52ae9fee670998bb268c09c24d148cc417162407700649e80e17cf7eb074f550eac60074a41932338fd8d24f29d37721bf720204f05e98cb8bd1eb8b7f485624fabb0bff90798db78e20d90d0ec5e5ed6840b0dbafd17446b74a13eae4b6eb43f531af795f967e5606b4f8c668e99848e61750d5e914e39889964879f150ec5956a2fb43f78b40057311c6a6bcab7a5606e95deb1eae13ffbbf2feed6617cd563eb8de9bb2939a5740f9529e897f49b03c60257b070fd4faee501b85337c6ad1c6577ce0baaaa7232c7e729ef40d782c9d28909181283753a556bbe33f5269a48e3d52dd91fbd9bcb63d8c3f8188ed7f5b2898277c0a19fb2ecc358c9ba5c725c7b12691a9e28b73e787054ec07c29e937d02d00a007e960e96ccbae234f59e633c00c403d6eeb546684d4150d16b1fb38486774292c0eac59fcf9aef7b26e594c6c7a614521fa90bf363ed249325c2ac789abe3f9410cbb4c2f9d6c73077dc60cfe17b422bdc81563db19eb23449d487f584e43968b15d58ba04e6d11a4dab99fa80a3ca1bec83270387ecf1d7acdc39a5b6d1a78f85bf8a86f862ad06568c858d95dfac508165fc47ddef331f146c670a03d8377c5e6f733da0ef07da416a773db2c7d507da80eb7cfff00d21482e35096c187a455dd23e88c18d623302fa8080f064e820be334b26026d636c94de4d980cc715aaa113a14533513035dd7d06235393</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">文章已加密, 请输入密码.</span>      </label>    </div>  </div></div><script data-pjax src="/yunyd/lib/hbe.js"></script><link href="/yunyd/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">这里有东西被加密了，需要输入密码查看哦。</summary>
    
    
    
    <category term="打招呼" scheme="https://gitee.com/yunyd/categories/%E6%89%93%E6%8B%9B%E5%91%BC/"/>
    
    
    <category term="介绍" scheme="https://gitee.com/yunyd/tags/%E4%BB%8B%E7%BB%8D/"/>
    
  </entry>
  
</feed>
