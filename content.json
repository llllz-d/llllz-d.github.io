{"meta":{"title":"llllz_liu","subtitle":"llllzの博客","description":"计算机 | 软件工程","author":"llllz.","url":"https://gitee.com/yunyd","root":"/yunyd/"},"pages":[{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2023-08-01T03:34:54.609Z","comments":true,"path":"404.html","permalink":"https://gitee.com/yunyd/404.html","excerpt":"","text":""},{"title":"","date":"2023-08-01T03:34:54.752Z","updated":"2023-08-01T03:34:54.752Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"https://gitee.com/yunyd/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"","date":"2023-08-01T03:34:54.756Z","updated":"2023-08-01T03:34:54.756Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"https://gitee.com/yunyd/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2023-08-01T03:34:54.629Z","comments":true,"path":"List/index.html","permalink":"https://gitee.com/yunyd/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2023-08-01T03:34:54.750Z","comments":true,"path":"about/index.html","permalink":"https://gitee.com/yunyd/about/index.html","excerpt":"","text":""},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2023-08-01T03:34:54.757Z","comments":true,"path":"resource/index.html","permalink":"https://gitee.com/yunyd/resource/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2023-08-01T03:34:54.753Z","comments":true,"path":"categories/index.html","permalink":"https://gitee.com/yunyd/categories/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2023-08-01T03:34:54.751Z","comments":true,"path":"archives/index.html","permalink":"https://gitee.com/yunyd/archives/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2023-08-01T03:34:54.758Z","comments":true,"path":"tags/index.html","permalink":"https://gitee.com/yunyd/tags/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2023-08-01T03:34:54.631Z","comments":true,"path":"List/music/index.html","permalink":"https://gitee.com/yunyd/List/music/index.html","excerpt":"","text":""},{"title":"留言板","date":"2023-07-19T16:00:00.000Z","updated":"2023-08-10T23:19:38.396Z","comments":true,"path":"contact/index.html","permalink":"https://gitee.com/yunyd/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 llllzの友链信息 博客名称: llllzの博客 博客网址: http://yunyd.gitee.io 博客介绍: The harder you work, the luckier you will be"},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2023-08-01T03:34:54.630Z","comments":true,"path":"List/movies/index.html","permalink":"https://gitee.com/yunyd/List/movies/index.html","excerpt":"","text":""},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2023-08-01T09:40:55.431Z","comments":true,"path":"friends/index.html","permalink":"https://gitee.com/yunyd/friends/index.html","excerpt":"","text":""},{"title":"相册","date":"2023-08-01T03:34:54.619Z","updated":"2023-08-01T03:34:54.619Z","comments":true,"path":"List/galleries/index.html","permalink":"https://gitee.com/yunyd/List/galleries/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2023-08-01T03:34:54.632Z","comments":true,"path":"List/tools/index.html","permalink":"https://gitee.com/yunyd/List/tools/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2023-08-01T03:34:54.620Z","updated":"2023-08-01T03:34:54.620Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"https://gitee.com/yunyd/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2023-08-01T03:34:54.621Z","updated":"2023-08-01T03:34:54.621Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"https://gitee.com/yunyd/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2023-08-01T03:34:54.620Z","updated":"2023-08-01T03:34:54.620Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"https://gitee.com/yunyd/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2023-08-01T03:34:54.622Z","updated":"2023-08-01T03:34:54.622Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"https://gitee.com/yunyd/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2023-08-01T03:34:54.625Z","updated":"2023-08-01T03:34:54.625Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"https://gitee.com/yunyd/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2023-08-01T03:34:54.625Z","updated":"2023-08-01T03:34:54.625Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"https://gitee.com/yunyd/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2023-08-01T03:34:54.624Z","updated":"2023-08-01T03:34:54.624Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"https://gitee.com/yunyd/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2023-08-01T03:34:54.623Z","updated":"2023-08-01T03:34:54.623Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"https://gitee.com/yunyd/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2023-08-01T03:34:54.626Z","updated":"2023-08-01T03:34:54.626Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"https://gitee.com/yunyd/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2023-08-01T03:34:54.627Z","updated":"2023-08-01T03:34:54.627Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"https://gitee.com/yunyd/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2023-08-01T03:34:54.628Z","updated":"2023-08-01T03:34:54.628Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"https://gitee.com/yunyd/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2023-08-01T03:34:54.629Z","updated":"2023-08-01T03:34:54.629Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"https://gitee.com/yunyd/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""}],"posts":[{"title":"volatile与JMM -6","slug":"volatile与JMM  -6","date":"2023-08-11T14:06:31.000Z","updated":"2023-08-14T14:20:16.680Z","comments":true,"path":"posts/3885bbd.html","link":"","permalink":"https://gitee.com/yunyd/posts/3885bbd.html","excerpt":"","text":"volatile与JMM6.1 被volatile修饰的变量有两大特点 特点： 可见性 有序性：有排序要求，有时需要禁重排 内存语义 当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值立即刷新回主内存中 当读一个volatile变量时，JMM会把该线程对应的本地内存设置为无效，重新回到主内存中读取最新共享变量的值 所以volatile的写内存语义是直接刷新到主内存中，读的内存语义是直接从主内存中读取 volatile凭什么可以保证可见性和有序性？ 内存屏障Memory Barrier 6.2内存屏障（面试重点必须拿下）6.2.1 生活case 没有管控，顺序难保 设定规则，禁止乱序—-&gt;上海南京路武警当红灯 再说vilatile两大特性： 可见：写完后立即刷新回主内存并及时发出通知，大家可以去主内存拿最新版，前面的修改对后面所有线程可见 有序性（禁重排）： 重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段，有时候会改变程序语句的先后顺序，若不存在数据依赖关系，可以重排序；存在数据依赖关系，禁止重排序；但重排后的指令绝对不能改变原有的串行语义！这点在并发设计中必须要重点考虑！ 6.2.2 是什么内存屏障（也称内存栅栏，屏障指令等）是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作，避免代码重排序。内存屏障其实就是一种JVM指令，Java内存模型的重排规则会要求Java编译器在生成JVM指令时插入特定的内存屏障指令，通过这些内存屏障指令，volatile实现了Java内存模型中的可见性和有序性（禁重排），但volatile无法保证原子性 内存屏障之前的所有写操作都要回写到主内存 内存屏障之后的所有读操作都能获得内存屏障之前的所有写操作的最新结果（实现了可见性） 写屏障(Store Memory Barrier)：告诉处理器在写屏障之前将所有存储在缓存(store buffers)中的数据同步到主内存，也就是说当看到Store屏障指令，就必须把该指令之前的所有写入指令执行完毕才能继续往下执行 读屏障(Load Memory Barrier)：处理器在读屏障之后的读操作，都在读屏障之后执行。也就是说在Load屏障指令之后就能够保证后面的读取数据指令一定能够读取到最新的数据。 因此重排序时，不允许把内存屏障之后的指令重排序到内存屏障之前。一句话：对一个volatile变量的写，先行发生于任意后续对这个volatile变量的读，也叫写后读。 6.2.3 内存屏障分类 粗分两种： 读屏障（Load Barrier）：在读指令之前插入读屏障，让工作内存或CPU高速缓存 当中的缓存数据失效，重新回到主内存中获取最新数据。 写屏障（Store Barrier）：在写指令之后插入写屏障，强制把缓冲区的数据刷回到主内存中。 细分四种： 屏障类型 指令示例 说明 LoadLoad Load1;LoadLoad;Load2 保证Load1的读取操作在Load2及后续读取操作之前执行 StoreStore Store1;StoreStore;Store2 在store2及其后的写操作执行前，保证Store1的写操作已经刷新到主内存 LoadStore Load1;LoadStore;Store2 在Store2及其后的写操作执行前，保证Load1的读操作已经结束 StoreLoad Store1;StoreLoad;Load2 保证Store1的写操作已经刷新到主内存后，Load2及其后的读操作才能执行 6.2.4 困难内容 什么叫保证有序性？—–&gt;通过内存屏障禁重排 重排序有可能影响程序的执行和实现，因此，我们有时候希望告诉JVM别自动重排序，我这里不需要重排序，一切听我的。 对于编译器的重排序，JMM会根据重排序的规则，禁止特定类型的编译器重排序 对于处理器的重排序，Java编译器在生成指令序列的适当位置，插入内存屏障指令，来禁止特定类型的处理器排序。 happens-before之volatile变量规则 第一个操作 第二个操作：普通读写 第二个操作：volatile读 第二个操作：volatile写 普通读写 可以重排 可以重排 不可以重排 volatile读 不可以重排 不可以重排 不可以重排 volatile写 可以重排 不可以重排 不可以重排 当第一个操作为volatile读时，不论第二个操作是什么，都不能重排序，这个操作保证了volatile读之后的操作不会被重排到volatile读之前。 当第一个操作为volatile写时，第二个操作为volatile读时，不能重排 当第二个操作为volatile写时，不论第一个操作是什么，都不能重排序，这个操作保证了volatile写之前的操作不会被重排到volatile写之后 JMM就将内存屏障插入策略分为4种规则 读屏障：在每个volatile读操作的后面插入一个LoadLoad屏障或者LoadStore屏障 写屏障：在每个volatile写操作的前面插入StoreStore屏障；在每个volatile写操作的后面插入StoreLoad屏障； 6.3 volatile特性6.3.1 保证可见性保证不同线程对某个变量完成操作后结果及时可见，即该共享变量一旦改变所有线程立即可见 Code 不加volatile，没有可见性，程序无法停止 加了volatile，保证可见性，程序可以停止 加了volatile保证可见性 public class VolatileSeeDemo { /** * t1 -------come in * main 修改完成 * t1 -------flag被设置为false，程序停止 */ static volatile boolean flag = true; public static void main(String[] args) { new Thread(() -&gt; { System.out.println(Thread.currentThread().getName() + \"\\t-------come in\"); while (flag) { } System.out.println(Thread.currentThread().getName() + \"\\t-------flag被设置为false，程序停止\"); }, \"t1\").start(); try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); } //更新flag值 flag = false; System.out.println(Thread.currentThread().getName() + \"\\t 修改完成\"); } } volatile变量的读写过程（了解即可） 6.3.2 没有原子性volatile变量的符合操作不具有原子性 对于voaltile变量具备可见性，JVM只是保证从主内存加载到线程工作内存的值是最新的，也仅仅是数据加载时是最新的。但是多线程环境下，“数据计算”和“数据赋值”操作可能多次出现，若数据在加载之后，若主内存volatile修饰变量发生修改之后，线程工作内存的操作将会作废去读主内存最新值，操作出现写丢失问题。即各线程私有内存和主内存公共内存中变量不同步，进而导致数据不一致。由此可见volatile解决的是变量读时的可见性问题，但无法保证原子性，对于多线程修改主内存共享变量的场景必须加锁同步。 至于怎么去理解这个写丢失的问题，就是再将数据读取到本地内存到写回主内存中有三个步骤：数据加载—-&gt;数据计算—-&gt;数据赋值，如果第二个线程在第一个线程读取旧值与写回新值期间读取共享变量的值，那么第二个线程将会与第一个线程一起看到同一个值，并执行自己的操作，一旦其中一个线程对volatile修饰的变量先行完成操作刷回主内存后，另一个线程会作废自己的操作，然后重新去读取最新的值再进行操作，这样的话，它自身的那一次操作就丢失了，这就造成了 线程安全失败，因此，这个问题需要使用synchronized修饰以保证线程安全性。 结论：volatile变量不适合参与到依赖当前值的运算，如i++，i=i+1之类的，通常用来保存某个状态的boolean值或者int值，也正是由于volatile变量只能保证可见性，在不符合以下规则的运算场景中，我们仍然要通过加锁来保证原子性： 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值 变量不需要与其他的状态变量共同参与不变约束 面试回答为什么不具备原子性：举例i++的例子，在字节码文件中，i++分为三部，间隙期间不同步非原子操作 对于volatile变量，JVM只是保证从主内存加载到线程工作内存的值是最新的，也就是数据加载时是最新的，如果第二个线程在第一个线程读取旧值和写回新值期间读取i的域值，也就造成了线程安全问题。 6.3.3 指令禁重排 在每一个volatile写操作前面插入一个StoreStore屏障—&gt;StoreStore屏障可以保证在volatile写之前，其前面所有的普通写操作都已经刷新到主内存中。 在每一个volatile写操作后面插入一个StoreLoad屏障—&gt;StoreLoad屏障的作用是避免volatile写与后面可能有的volatile读/写操作重排序 在每一个volatile读操作后面插入一个LoadLoad屏障—&gt;LoadLoad屏障用来禁止处理器把上面的volatile读与下面的普通读重排序 在每一个volatile读操作后面插入一个LoadStore屏障—&gt;LoadTore屏障用来禁止处理器把上面的volatile读与下面的普通写重排序 案例说明（volatile读写前或后加了屏障保证有序性）： 6.4 如何正确使用volatile 单一赋值可以，但是含复合运算赋值不可以（i++之类的） volatile int a = 10; volatile boolean flag = true; 状态标志，判断业务是否结束 作为一个布尔状态标志，用于指示发生了一个重要的一次性事件，例如完成初始化或任务结束 开销较低的读，写锁策略 当读远多于写，结合使用内部锁和volatile变量来减少同步的开销 原理是：利用volatile保证读操作的可见性，利用synchronized保证符合操作的原子性 DCL双端锁的发布 问题描述：首先设定一个加锁的单例模式场景 在单线程环境下（或者说正常情况下），在“问题代码处”，会执行以下操作，保证能获取到已完成初始化的实例： 隐患：在多线程环境下，在“问题代码处”，会执行以下操作，由于重排序导致2，3乱序，后果就是其他线程得到的是null而不是完成初始化的对象，其中第3步中实例化分多步执行（分配内存空间、初始化对象、将对象指向分配的内存空间），某些编译器为了性能原因，会将第二步和第三步重排序，这样某个线程肯能会获得一个未完全初始化的实例： 多线程下的解决方案：加volatile修饰 6.5 本章最后的小总结6.5.1 volatile可见性 volatile关键字保证可见性： 对一个被volatile关键字修饰的变量 1 写操作的话，这个变量的最新值会立即刷新回到主内存中 2 读操作的话，总是能够读取到这个变量的最新值，也就是这个变量最后被修改的值 3 当某个线程收到通知，去读取volatile修饰的变量的值的时候，线程私有工作内存的数据失效，需要重新回到主内存中去读取最新的数据。 6.5.2 volatile没有原子性6.5.3 volatile禁重排 6.5.4 凭什么我们Java写了一个volatile关键字，系统底层加入内存屏障？两者的关系如何勾搭？ 6.5.5 内存屏障是什么？是一种屏障指令，它使得CPU或编译器对屏障指令的前和后所发出的内存操作执行一个排序的约束。也称为内存栅栏或栅栏指令。 6.5.6 内存屏障能干吗？ 阻止屏障两边的指令重排序 写操作时加入屏障，强制将线程私有工作内存的数据刷回主物理内存 读操作时加入屏障，线程私有工作内存的数据失效，重新回到主物理内存中获取最新值 6.5.7 内存屏障四大指令 6.5.8 3句话总结 volatile写之前的操作，都禁止重排序到volatile之后 volatile读之后的操作，都禁止重排序到volatile之前 volatile写之后volatile读，禁止重排序","categories":[{"name":"JUC并发编程","slug":"JUC并发编程","permalink":"https://gitee.com/yunyd/categories/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"JUC并发编程","slug":"JUC并发编程","permalink":"https://gitee.com/yunyd/tags/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"author":"llllz."},{"title":"校园美食圈","slug":"校园美食圈","date":"2023-08-09T08:02:31.000Z","updated":"2023-08-14T09:57:58.903Z","comments":true,"path":"posts/38f0fa30.html","link":"","permalink":"https://gitee.com/yunyd/posts/38f0fa30.html","excerpt":"","text":"校园美食圈项目所用到的技术：Spring 相关： Spring Boot 2.x Spring MVC 数据存储层： MySQL：存储数据 MyBatis Plus：数据访问框架 Redis 相关： spring-data-redis：操作 Redis Lettuce：操作 Redis 的高级客户端 Apache Commons Pool：用于实现 Redis 连接池 Redisson：基于 Redis 的分布式数据网格 工具库： HuTool：工具库合集 Lombok：注解式代码生成工具 后端： 为方便其他业务后续使用缓存，使用泛型 + 函数式编程实现了缓存访问静态方法，并解决了缓存雪崩、缓存穿透等问题； 优惠券秒杀： 使用Redis + Lua 脚本实现库存预检，并通过Stream队列实现订单的异步创建，解决了超卖问题，实现一人一单； 店铺查询：使用Redis 对高频访问店铺进行缓存，降低DB压力同时提高数据查询性能； 短信登陆：使用Redis实现分布式Session，解决了集群间登录态同步问题；使用Hash代替String来存储用户信息，节约了内存并便于单字段的修改； 使用Redis Set数据结构实现用户关注、共同关注功能； 使用常量类全局管理Redis Key前缀、TTL等，保证了键空间的业务隔离，减少冲突； 项目功能：登陆界面： 项目主页面：登录进来后，展示的主页面 从主页面点击美食：会展示商家列表信息 这个是探店的人发表的评论 优惠券秒杀：","categories":[{"name":"项目","slug":"项目","permalink":"https://gitee.com/yunyd/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"项目","slug":"项目","permalink":"https://gitee.com/yunyd/tags/%E9%A1%B9%E7%9B%AE/"}],"author":"llllz."},{"title":"Java内存模型之JMM  -5","slug":"Java内存模型之JMM  -5","date":"2023-08-09T01:06:49.000Z","updated":"2023-08-15T01:05:30.508Z","comments":true,"path":"posts/6c9d84e4.html","link":"","permalink":"https://gitee.com/yunyd/posts/6c9d84e4.html","excerpt":"","text":"5. Java内存模型之JMM5.1 先从大场面试开始●你知道什么是Java内存模型JMM吗？ ●JMM和volatile他们两个之间的关系？ ●JMM没有那些特征或者它的三大特征是什么？ ●为什么要有JMM，它为什么出现？作用和功能是什么？ ●happens-before先行并发原则你有了解过吗？ 5.2 计算机硬件存储体系 CPU的运行并不是直接操作内存而是先把内存里面的数据读到缓存，而内存的读和写操作的时候会造成不一致的问题。JVM规范中试图定义一种Java内存模型来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致性的内存访问效果。 5.3 Java内存模型Java Memory ModelJMM（Java内存模型Java Memory Model）本身是一种抽象的概念并不真实存在，它仅仅描述的是一组约定或规范，通过这组规范定义了程序中（尤其是多线程）各个变量的读写访问方式并决定一个线程对共享变量的写入以及如何变成对另一个线程可见，关键技术点都是围绕多线程的原子性、可见性和有序性展开的。 能干嘛？ 通过JMM来实现线程和主内存之间的抽象关系 屏蔽各个硬件平台和操作系统的内存访问差异以实现让Java程序再各种平台下都能达到一致性的内存访问效果。 5.4 JMM规范下三大特性 可见性：是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道该变更，JMM规定了所有的变量都存储在主内存中。 系统中主内存共享变量数据修改被写入的时机是不确定的，多线程并发下很可能出现“脏读”，所以每个线程都有自己的工作内存，线程自己的工作内存中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在线程自己的工作内存中进行，而不能够直接写入主内存中的变量，不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。 线程脏读 主内存中有变量X，初始值为0 线程A要将X加1，先将X=0拷贝到自己的私有内存中，然后更新X的值 线程A将更新后的X值回刷到主内存的时间是不固定的 刚好在线程A没有回刷x到主内存时，线程B同样从主内存中读取X，此时为0，和线程A一样的操作，最后期盼的X=2就会变成X=1 原子性：指一个操作是不可被打断的，即多线程环境下，操作不能被其他线程干扰 有序性：对于一个线程的执行代码而言，我们总是习惯性地认为代码的执行总是从上到下，有序执行。但为了提升性能，编译器和处理器通常会对指令序列进行重新排序。Java规范规定JVM线程内部维持顺序化语义，即只要程序的最终结果与它顺序话执行的结果相等，那么指令的执行顺序可以与代码顺序不一致，此过程叫指令的重排序。 优缺点： JVM能根据处理器特性（CPU多级缓存系统、多核处理器等）适当的对机器指令进行重排序，使机器指令更符合CPU的执行特性，最大限度的发挥机器性能。 但是指令重排可以保证串行语义一致，但没有义务保证多线程的语义也一致（即可能产生“脏读”），简单而言就是两行以上不相干的代码在执行的时候有可能先执行的不是第一条，不见得是从上到下顺序执行，执行顺序会被优化。 从源码到最终执行示例图： 单线程环境里确实能够保证程序最终执行结果和代码顺序执行的结果一致 处理器在进行重排序时必须考虑到指令之间的数据依赖性 多线程环境中线程交替执行，由于编译器优化重排的存在，可能出现乱序现象，两个线程使用的变量能否保证一致性是无法确定的，结果无法预测 5.5JMM规范下多线程对变量的读写过程由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存（有的地方成为栈空间），工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作（读写赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到线程自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，各个线程中的工作内存存储着主内存中的变量副本拷贝，因此不同的线程无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成，其简要访问过程如下图： JMM定义了线程和主内存之间的抽象关系： 线程之间的共享变量存储在主内存中（从硬件角度讲就是内存条） 每个线程都有一个自己的本地工作内存，本地工作内存中存储了该线程用来读写共享变量的副本（从硬件角度来说就是CPU的缓存） 小总结： 我们定义的所有共享变量都储存在物理主内存中 每个线程都有自己独立的工作内存，里面保证该线程使用到的共享变量的副本（主内存中该变量的一份拷贝） 线程对共享变量所有的操作都必须先在线程自己的工作内存中进行后写回主内存，不能直接从主内存在读写（不能越级） 不同线程之间也无法直接访问其他线程的工作内存中的变量，线程间变量值的传递需要通过主内存来进行（同级不能互相访问） 5.6 JMM规范下多线程先行发生原则之happens-before在JVM中，如果一个操作执行的结果需要对另一个操作可见或者代码重排序，那么这两个操作之间必须存在happens-before（先行发生）原则，逻辑上的先后关系。 5.6.1 x,y案例说明 ——————- ——————- x = 5 线程A执行 y = x 线程B执行 上述称之为： 写后读 问题？ y是否等于5呢？如果线程A的操作（x=5）happens-before（先行发生）线程B的操作(y=x)，那么可以确定线程B执行y=5一定成立；如果他们不存在happens-before原则，那么y=5不一定成立这就是happens-before原则的为例———–&gt;包含可见性和有序性的约束 5.6.2 先行并发原则说明如果Java内存模型中所有的有序性都仅靠volatile和synchronized来完成，那么有很多操作都将变得非常罗嗦，但是我们在编写Java并发代码的时候并没有察觉到这一点。 我们没有时时、处处、次次，添加volatile和synchronized来完成程序，这是因为Java语言中JMM原则下，有一个“先行发生”（happens-before）的原则限制和规矩，给你理好了规矩！ 这个原则非常重要：它是判断数据是否存在竞争，线程是否安全的非常有用的手段。依赖这个原则，我们可以通过几条简单规则一揽子解决并发环境下两个操作之间是否可能存在冲突的所有问题，而不需要陷入Java内存模型晦涩难懂的底层编译原理之中。 5.6.3 happens-before总原则 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前 如果两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。 5.6.4 happens-before之8条从JDK 5开始，Java使用新的JSR-133内存模型，提供了 happens-before 原则来辅助保证程序执行的原子性、可见性以及有序性的问题，它是判断数据是否存在竞争、线程是否安全的依据，happens-before 原则内容如下： 次序规则：一个线程内，按照代码的顺序，写在前面的操作先行发生于写在后面的操作，也就是说前一个操作的结果可以被后续的操作获取（保证语义串行性，按照代码顺序执行）。比如前一个操作把变量x赋值为1，那后面一个操作肯定能知道x已经变成了1 锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作（后面指时间上的先后） volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，前面的写对后面的读是可见的，这里的后面同样指时间上的先后 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C 线程启动规则（Thread start Rule）：Thread对象的start()方法先行发生于此线程的每一个动作 线程中断规则（Thread Interruption Rule）： 对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生 可以通过Thread.interrupted()检测到是否发生中断 也就是说你要先调用interrupt()方法设置过中断标志位，我才能检测到中断发生 线程终止规则（Thread Termination Rule）：线程中的所有操作都优先发生于对此线程的终止检测，我们可以通过isAlive()等手段检测线程是否已经终止执行 对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize(）方法的开始——-&gt;对象没有完成初始化之前，是不能调用finalized()方法的 5.6.5 happens-before小总结 在Java语言里面，Happens-before的语义本质上是一种可见性 A happens-before B ,意味着A发生过的事情对B而言是可见的，无论A事件和B事件是否发生在同一线程里 JVM的设计分为两部分： 一部分是面向我们程序员提供的，也就是happens-before规则，它通俗易懂的向我们程序员阐述了一个强内存模型，我们只要理解happens-before规则，就可以编写并发安全的程序了 另一部分是针对JVM实现的，为了尽可能少的对编译器和处理器做约束从而提升性能，JMM在不影响程序执行结果的前提下对其不做要求，即允许优化重排序，我们只要关注前者就好了，也就是理解happens-before规则即可，其他繁杂的内容由JMM规范结合操作系统给我们搞定，我们只写好代码即可 5.6.6 案例说明初始案例演示： private int value =0; public int getValue(){ return value; } public int setValue(){ return ++value; } 问题描述：假设存在线程A和B，线程A先（时间上的先后）调用了setValue()方法，然后线程B调用了同一个对象的getValue()方法，那么线程B收到的返回值是什么？ 答案：不一定 分析happens-before规则（规则5，6，7，8可以忽略，和代码无关） 1 由于两个方法由不同线程调用，不满足一个线程的条件，不满足程序次序规则 2 两个方法都没有用锁，不满足锁定规则 3 变量没有使用volatile修饰，所以不满足volatile变量规则 4 传递规则肯定不满足 综上：无法通过happens-before原则推导出线程A happens-before 线程B，虽然可以确定时间上线程A优于线程B，但就是无法确定线程B获得的结果是什么，所以这段代码不是线程安全的 注意： ● 如果两个操作的执行次序无法从happens-before原则推导出来，那么就不能保证他们的有序性，虚拟机可以随意对他们进行重排序 如何修复？ 把getter/setter方法都定义为synchronized方法——-&gt;不好，重量锁，并发性下降 把getter/setter方法都定义为synchronized方法： private int value =0; public synchronized int getValue(){ return value; } public synchronized int setValue(){ return ++value; } 把Value定义为volatile变量，由于setter方法对value的修改不依赖value的原值，满足volatile关键字使用场景 把Value定义为volatile变量： /** * 利用volatile保证读取操作的可见性， * 利用synchronized保证符合操作的原子性结合使用锁和volatile变量来减少同步的开销 */ private volatile int value =0; public int getValue(){ return value; } public synchronized int setValue(){ return ++value; }","categories":[{"name":"JUC并发编程","slug":"JUC并发编程","permalink":"https://gitee.com/yunyd/categories/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"JUC并发编程","slug":"JUC并发编程","permalink":"https://gitee.com/yunyd/tags/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"author":"llllz."},{"title":"OPEN-API开放平台","slug":"OPEN-API开放平台","date":"2023-08-07T05:12:22.000Z","updated":"2023-08-12T06:49:44.201Z","comments":true,"path":"posts/574f1a5b.html","link":"","permalink":"https://gitee.com/yunyd/posts/574f1a5b.html","excerpt":"","text":"OPEN-API开放平台项目所用到的技术： Java Spring Boot MySQL 数据库 MyBatis-Plus 及 MyBatis X 自动生成 Swagger + Knife4j 接口文档生成 API 签名认证（Http 调用） Spring Boot Starter（SDK 开发） Dubbo 分布式（RPC、Nacos） Spring Cloud Gateway 微服务网关 Hutool、Apache Common Utils、Gson 等工具库 后端： 根据业务流程，将整个项目后端划分为 web 系统、模拟接口、公共模块、客户端 SDK、API 网关这 5 个子项目，并使用 Maven 进行多模块依赖管理和打包。 基于 MyBatis Plus 框架的 QueryWrapper 实现对 MySQL 数据库的灵活查询，并配合 MyBatis X 插件自动生成后端 CRUD 基础代码，减少重复工作。 使用 Swagger + Knife4j 自动生成 OpenAPI 规范的接口文档，降低前后端协作成本。 为防止接口被恶意调用，设计 API 签名认证算法，为用户分配唯一 ak / sk 以鉴权，保障调用的安全性、便于统计接口调用次数。 为解决开发者调用成本过高的问题（须自己使用 HTTP + 封装签名去调用接口），基于 Spring Boot Starter 开发了客户端 SDK，一行代码 即可调用接口，提高开发体验。 选用 Spring Cloud Gateway 作为 API 网关，实现了路由转发、访问控制、流量染色，并集中处理签名校验、请求参数校验、接口调用统计等业务逻辑，提高安全性的同时、便于系统开发维护。 为解决多个子系统内代码大量重复的问题，抽象模型层和业务层代码为公共模块，并使用 Dubbo RPC 框架实现子系统间的高性能接口调用，大幅减少重复代码。 项目简介一个提供API接口供开发者调用的平台 管理员可以接入并发布接口，统计分析个接口调用情况；用户可以注册登录并开通接口调用权限，然后可以浏览接口及在线调试，还能使用客户端SDK轻松在代码中调用接口。 项目功能及各部分页面介绍，如下图：登陆界面： 主页浏览（管理员身份）： 接口管理（管理员身份）：管理员身份具有管理页等选项框，用于接口管理和接口分析这两个功能， 接口管理用来发布、下线接口，对接口信息的增删改查等等功能 点击修改，弹出此接口信息的信息框用来进行修改操作 接口分析（管理员身份）：用于调查接口里面的top3（接口调用次数最多的前三名接口名称及其调用次数），方便管理员进行接口分析和管理 在线调试：按照要求输入，即可调用已经发布上线的接口，并使用其功能 此处是一个功能简单的接口，在请求参数按照规范来输入，点击调用，即可调用该接口的功能。该接口的功能是：输入一个名字，即可返回调用的类型 + 用户输入的名字，调用成功后会弹出调用成功的框，并在下面返回结果出得到返回结果。 主页浏览（非管理员身份）:仅可以在线调用接口，不能对接口进行权限处理等功能 多个后端：开放平台项目涉及到了多个系统的交互（不止有一个后端），包括了API签名认证、网关、RPC、分布式等知识 （以上项目大体功能等仅粗略展示，如功能解释的不详细，还望见谅！！）.","categories":[{"name":"项目","slug":"项目","permalink":"https://gitee.com/yunyd/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"项目","slug":"项目","permalink":"https://gitee.com/yunyd/tags/%E9%A1%B9%E7%9B%AE/"}],"author":"llllz."},{"title":"商家外卖","slug":"商家外卖","date":"2023-08-07T05:12:22.000Z","updated":"2023-08-12T06:49:50.755Z","comments":true,"path":"posts/7161264.html","link":"","permalink":"https://gitee.com/yunyd/posts/7161264.html","excerpt":"","text":"商家外卖项目所用到的技术： Spring Boot SSM + Lombok MyBatis Plus Spring Cache Redis Sharding JDBC 读写分离 部署：前后端不分离 jar 包部署 后端： 为集中处理系统异常，自定义统一的错误码，并封装了 全局异常处理器 ，屏蔽了项目冗余的报错细节、便于接口调用方理解和统一处理。 基于静态 ThreadLocal 封装了线程隔离的全局上下文对象，便于在请求内部存取用户信息，减少用户远程查询次数。 为兼容请求参数 date 类型的序列化，自定义 Jackson 对象映射器处理日期；并扩展 SpringMVC 的消息转换器，实现自动序列化。 自定义 MyBatis Plus 的 MetaObjectHandler，配合全局上下文实现写数据前的创建时间、用户 id 字段的自动填充。 遵循 Restful 设计规范编写接口，降低前后端接口沟通和理解成本。 为解决原生 Jdk 序列化器导致的缓存 key 值乱码问题，自定义 RedisTemplate Bean 的 Redis Key 序列化器为 StringRedisSerializer。 使用 Knife4j + Swagger 自动生成后端接口文档，并通过编写 ApiOperation 等注解补充接口注释，避免了人工编写维护文档的麻烦。 为省去重复编写用户校验的麻烦，基于 WebFilter 实现全局登录校验；并通过 AntPathMatcher 来匹配动态请求路径，实现灵活的可选鉴权。 为保证数据的完整性和一致性，使用 @Transactional 实现数据库事务，并配置 rollbackFor = Exception.class 来支持受检异常的事务回滚。 为提高信息页加载速度，基于 Spring Cache 注解 + Redis 实现对信息的自动缓存，来降低数据库压力的同时将接口响应耗时 为降低开发成本，使用 MyBatis Plus 框架自动生成业务的增删改查重复代码，并使用 LambdaQueryWrapper 实现更灵活地自定义查询。 为提高数据库整体读写性能，配置 MySQL 主从同步，并使用 sharding-jdbc 实现业务无侵入的读写分离。 封装全局 Axios 请求实例，添加全局请求拦截和全局异常响应处理器，减少重复的状态码判断、提升项目可维护性。 项目功能及各部分页面介绍，如下图：项目分为用户端和管理端：用户端介绍：页面输入手机号，首先会对手机号码有一个校验，不符合规则的的手机号会进行提示。然后点击验证码会直接给出验证码，由于模拟真实的短信服务需要付费并调用XX云SDK接入短信服务，为了节省成本，我直接将返回的验证码写在输入框里（模拟一下接收短信的流程） 注册登录进来后就可以查看商家信息（都哪有些菜品，套餐之类的） 随机选择一个，点击选择规格，会弹出如下框，选择适合自己的口味并点击加入购物车 点击完加入购物车之后，即可在购物车中显示，如果同一菜品想要多份的话，就点击➕来增加份数，购物车显示的金额也会随之更新 点击去结算的按钮会到支付页面，当然如果是新注册的账号，则会先让你留下收货地址，如下图 保存完收货地址，就可以进行支付了 管理端介绍：管理端是用来商家来上传一些菜品，套餐之类的，并包括员工信息等，可以对员工信息、菜品、套餐等信息进行增删改查等功能 下图为管理端的登陆页面： 点击登录，来到管理端页面 分为左列几个功能，能对响应分类进行增上改查，拿员工管理界面的增上改查来举例子： 点击编辑，可以修改员工信息。点击添加员工可以进行添加，启用禁用功能是指如果员工加入企业或者退出企业，可以对他的账号进行封禁或者开启 点击修改，效果如下图： 其余界面如下，功能类似，都可以进行增删改查等功能： （以上项目大体功能等仅粗略展示，如功能解释的不详细，还望见谅！！）.","categories":[{"name":"项目","slug":"项目","permalink":"https://gitee.com/yunyd/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"项目","slug":"项目","permalink":"https://gitee.com/yunyd/tags/%E9%A1%B9%E7%9B%AE/"}],"author":"llllz."},{"title":"LockSupport与线程中断  -4","slug":"LockSupport与线程中断  -4","date":"2023-08-05T08:42:32.000Z","updated":"2023-08-14T14:08:47.568Z","comments":true,"path":"posts/b972fab5.html","link":"","permalink":"https://gitee.com/yunyd/posts/b972fab5.html","excerpt":"","text":"LockSupport与线程中断4.1 线程中断机制4.1.1 从阿里蚂蚁金服面试题讲起Java.lang.Thread下的三个方法: 如何中断一个运行中的线程？ 如何停止一个运行中的线程？ 4.1.2 什么是中断机制 首先，一个线程不应该由其他线程来强制中断或停止，而是应该由线程自己自行停止，自己来决定自己的命运，所以，Thread.stop,Thread.suspend,Thread.resume都已经被废弃了 其次，在Java中没有办法立即停止一条线程，然而停止线程却显得尤为重要，如取消一个耗时操作。因此，Java提供了一种用于停止线程的协商机制—-中断，也即中断标识协商机制 中断只是一种协作协商机制，Java没有给中断增加任何语法，中断的过程完全需要程序员自行实现。若要中断一个线程，你需要手动调用该线程interrupt方法，该方法也仅仅是将该线程对象的中断标识设置为true，接着你需要自己写代码不断检测当前线程的标识位，如果为true，表示别的线程请求这条线程中断，此时究竟应该做什么需要你自己写代码实现。 每个线程对象都有一个中断标识位，用于表示线程是否被中断；该标识位为true表示中断，为false表示未中断；通过调用线程对象的interrupt方法将该线程的标识位设置为true；可以在别的线程中调用，也可以在自己的线程中调用。 4.1.3 中断的相关API方法之三大方法说明 public void interrupt() 实例方法 Just to set the interrupt flag 实例方法仅仅是设置线程的中断状态为true，发起一个协商而不会立刻停止线程 public static boolean interrupted() 静态方法 Thread.interrupted(); 判断线程是否被中断并清除当前中断状态（做了两件事情） 1.返回当前线程的中断状态，测试当前线程是否已被中断 2.将当前线程的中断状态清零并重新设置为false，清除线程的中断状态 3.这个方法有点不好理解在于如果连续两次调用此方法，则第二次返回false，因为连续调用两次的结果可能不一样 public boolean isInterrupted() 实例方法 判断当前线程是否被中断（通过检查中断标志位） 4.1.4 大厂面试题中断机制考点 如何停止中断运行中的线程？ 通过一个volatile变量实现 volatile中断线程演示： public class InterruptDemo { static volatile boolean isStop = false; //volatile表示的变量具有可见性 public static void main(String[] args) { new Thread(() -&gt; { while (true) { if (isStop) { System.out.println(Thread.currentThread().getName() + \" isStop的值被改为true，t1程序停止\"); break; } System.out.println(\"-----------hello volatile\"); } }, \"t1\").start(); try { TimeUnit.MILLISECONDS.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -&gt; { isStop = true; }, \"t2\").start(); } } /** * -----------hello volatile * -----------hello volatile * -----------hello volatile * -----------hello volatile * -----------hello volatile * -----------hello volatile * t1 isStop的值被改为true，t1程序停止 */ 通过AutomicBoolean AutomicBoolean中断线程演示： public class InterruptDemo { static AtomicBoolean atomicBoolean = new AtomicBoolean(false); public static void main(String[] args) { new Thread(() -&gt; { while (true) { if (atomicBoolean.get()) { System.out.println(Thread.currentThread().getName() + \" atomicBoolean的值被改为true，t1程序停止\"); break; } System.out.println(\"-----------hello atomicBoolean\"); } }, \"t1\").start(); try { TimeUnit.MILLISECONDS.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -&gt; { atomicBoolean.set(true); }, \"t2\").start(); } } /** * -----------hello atomicBoolean * -----------hello atomicBoolean * -----------hello atomicBoolean * -----------hello atomicBoolean * -----------hello atomicBoolean * t1 atomicBoolean的值被改为true，t1程序停止 */ 通过Thread类自带的中断API实例方法实现—-在需要中断的线程中不断监听中断状态，一旦发生中断，就执行相应的中断处理业务逻辑stop线程。 interrupt() 和isInterrupted()组合使用来中断某个线程演示： public class InterruptDemo { static AtomicBoolean atomicBoolean = new AtomicBoolean(false); public static void main(String[] args) { Thread t1 = new Thread(() -&gt; { while (true) { if (Thread.currentThread().isInterrupted()) { System.out.println(Thread.currentThread().getName() + \" isInterrupted()的值被改为true，t1程序停止\"); break; } System.out.println(\"-----------hello isInterrupted()\"); } }, \"t1\"); t1.start(); try { TimeUnit.MILLISECONDS.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } //t2向t1放出协商，将t1中的中断标识位设为true，希望t1停下来 new Thread(() -&gt; t1.interrupt(), \"t2\").start(); //当然，也可以t1自行设置 t1.interrupt(); } } /** * -----------hello isInterrupted() * -----------hello isInterrupted() * -----------hello isInterrupted() * -----------hello isInterrupted() * t1 isInterrupted()的值被改为true，t1程序停止 */ 当前线程的中断标识为true，是不是线程就立刻停止？ 答案是不立刻停止，具体来说，当对一个线程，调用interrupt时： 如果线程处于正常活动状态，那么会将该线程的中断标志设置为true，仅此而已，被设置中断标志的线程将继续正常运行，不受影响，所以interrupt()并不能真正的中断线程，需要被调用的线程自己进行配合才行，对于不活动的线程没有任何影响。 如果线程处于阻塞状态（例如sleep,wait,join状态等），在别的线程中调用当前线程对象的interrupt方法，那么线程将立即退出被阻塞状态（interrupt状态也将被清除），并抛出一个InterruptedException异常。 第一种情况正常活动状态演示： public class InterruptDemo2 { public static void main(String[] args) { //实例方法interrupt()仅仅是设置线程的中断状态位为true，不会停止线程 Thread t1 = new Thread(() -&gt; { for (int i = 1; i &lt;= 300; i++) { System.out.println(\"------: \" + i); } /** * ------: 298 * ------: 299 * ------: 300 * t1线程调用interrupt()后的中断标志位02：true */ System.out.println(\"t1线程调用interrupt()后的中断标志位02：\" + Thread.currentThread().isInterrupted()); }, \"t1\"); t1.start(); System.out.println(\"t1线程默认的中断标志位：\" + t1.isInterrupted());//false try { TimeUnit.MILLISECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); } t1.interrupt();//true /** * ------: 251 * ------: 252 * ------: 253 * t1线程调用interrupt()后的中断标志位01：true */ System.out.println(\"t1线程调用interrupt()后的中断标志位01：\" + t1.isInterrupted());//true try { TimeUnit.MILLISECONDS.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } //2000毫秒后，t1线程已经不活动了，不会产生任何影响 System.out.println(\"t1线程调用interrupt()后的中断标志位03：\" + t1.isInterrupted());//false } } 第二种情况线程处于阻塞状态演示： public class InterruptDemo3 { public static void main(String[] args) { Thread t1 = new Thread(() -&gt; { while (true) { if (Thread.currentThread().isInterrupted()) { System.out.println(Thread.currentThread().getName() + \" 中断标志位为：\" + Thread.currentThread().isInterrupted() + \" 程序停止\"); break; } //sleep方法抛出InterruptedException后，中断标识也被清空置为false，如果没有在 //catch方法中调用interrupt方法再次将中断标识置为true，这将导致无限循环了 try { Thread.sleep(200); } catch (InterruptedException e) { //Thread.currentThread().interrupt(); e.printStackTrace(); } System.out.println(\"-------------hello InterruptDemo3\"); } }, \"t1\"); t1.start(); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -&gt; { t1.interrupt(); }, \"t2\").start(); } } 对于第二种情况的源码分析如下； 总之，需要记住的是中断只是一种协商机制，修改中断标识位仅此而已，不是立刻stop打断 静态方法Thread.interrupted()，谈谈你的理解？ 静态方法Thread.interrupted()演示： public class InterruptDemo4 { public static void main(String[] args) { /** * main false * main false * -----------1 * -----------2 * main true * main false */ System.out.println(Thread.currentThread().getName() + \"\\t\" + Thread.interrupted());//false System.out.println(Thread.currentThread().getName() + \"\\t\" + Thread.interrupted());//false System.out.println(\"-----------1\"); Thread.currentThread().interrupt(); System.out.println(\"-----------2\"); System.out.println(Thread.currentThread().getName() + \"\\t\" + Thread.interrupted());//true System.out.println(Thread.currentThread().getName() + \"\\t\" + Thread.interrupted());//false } } 对于静态方法Thread.interrupted()和实例方法isInterrupted()区别在于： 静态方法interrupted将会清除中断状态（传入的参数ClearInterrupted为true） 实例方法isInterrupted则不会（传入的参数ClearInterrupted为false） 4.1.5 总结 public void interrupt() 是一个实例方法，它通知目标线程中断，也仅仅是设置目标线程的中断标志位为true public boolean isInterrupted() 是一个实例方法，它判断当前线程是否被中断（通过检查中断标志位）并获取中断标志 public static boolean interrupted() 是一个静态方法，返回当前线程的中断真实状态（boolean类型）后会将当前线程的中断状态设为false，此方法调用之后会清楚当前线程的中断标志位的状态（将中断标志置为false了），返回当前值并清零置为false。 4.2 LockSupport是什么LockSupport是用来创建锁和其他同步类的基本线程阻塞原语，其中park()和unpack()而作用分别是阻塞线程和解除阻塞线程. 4.3 线程等待唤醒机制4.3.1 三种让线程等待和唤醒的方法 方式一：使用Object中的wait()方法让线程等待，使用Object中的notify()方法唤醒线程 方式二：使用JUC包中的Condition的await()方法让线程等待，使用signal()方法唤醒线程 方式三：LockSupport类可以阻塞当前线程以及唤醒指定被阻塞的线程 4.3.2 Object类中的wait和notify方法实现线程等待和唤醒 wait和notify方法必须要在同步代码块或者方法里面，且成对出现使用 先wait再notify才ok Object类中的wait和notify方法实现线程等待和唤醒演示: public class LockSupportDemo { public static void main(String[] args) { Object objectLock = new Object(); /** * t1 -----------come in * t2 -----------发出通知 * t1 -------被唤醒 */ new Thread(() -&gt; { synchronized (objectLock) { System.out.println(Thread.currentThread().getName() + \"\\t -----------come in\"); try { objectLock.wait(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + \"\\t -------被唤醒\"); } }, \"t1\").start(); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -&gt; { synchronized (objectLock) { objectLock.notify(); System.out.println(Thread.currentThread().getName() + \"\\t -----------发出通知\"); } }, \"t2\").start(); } } 4.3.3 Condition接口中的await和signal方法实现线程的等待和唤醒 Condition中的线程等待和唤醒方法，需要先获取锁 一定要先await后signal，不要反了 Condition接口中的await和signal方法实现线程的等待和唤醒演示: public class LockSupportDemo { public static void main(String[] args) { Lock lock = new ReentrantLock(); Condition condition = lock.newCondition(); /** * t1 -----------come in * t2 -----------发出通知 * t1 -----------被唤醒 */ new Thread(() -&gt; { lock.lock(); try { System.out.println(Thread.currentThread().getName() + \"\\t -----------come in\"); condition.await(); System.out.println(Thread.currentThread().getName() + \"\\t -----------被唤醒\"); } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); } }, \"t1\").start(); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -&gt; { lock.lock(); try { condition.signal(); System.out.println(Thread.currentThread().getName() + \"\\t -----------发出通知\"); } finally { lock.unlock(); } }, \"t2\").start(); } } 4.3.4 上述两个对象Object和Condition使用的限制条件 线程需要先获得并持有锁，必须在锁块（synchronized或lock）中 必须要先等待后唤醒，线程才能够被唤醒 4.3.5 LockSupport类中的park等待和unpark唤醒 是什么 LockSupport 是用于创建锁和其他同步类的基本线程阻塞原语 LockSupport类使用了一种名为Permit（许可）的概念来做到阻塞和唤醒线程的功能，每个线程都有一个许可（Permit），许可证只能有一个，累加上限是1。 主要方法 阻塞: Peimit许可证默认没有不能放行，所以一开始调用park()方法当前线程会阻塞，直到别的线程给当前线程发放peimit，park方法才会被唤醒。 park/park(Object blocker)——-阻塞当前线程/阻塞传入的具体线程 唤醒: 调用unpack(thread)方法后 就会将thread线程的许可证peimit发放，会自动唤醒park线程，即之前阻塞中的LockSupport.park()方法会立即返回。 unpark(Thread thread)——唤醒处于阻塞状态的指定线程 代码 LockSupport类中的park等待和unpark唤醒演示: public class LockSupportDemo { public static void main(String[] args) { /** * t1 -----------come in * t2 ----------发出通知 * t1 ----------被唤醒 */ Thread t1 = new Thread(() -&gt; { System.out.println(Thread.currentThread().getName() + \"\\t -----------come in\"); LockSupport.park(); System.out.println(Thread.currentThread().getName() + \"\\t ----------被唤醒\"); }, \"t1\"); t1.start(); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -&gt; { LockSupport.unpark(t1); System.out.println(Thread.currentThread().getName() + \"\\t ----------发出通知\"); }, \"t2\").start(); } } 重点说明（重要） LockSupport是用来创建锁和其他同步类的基本线程阻塞原语，所有的方法都是静态方法，可以让线程再任意位置阻塞，阻塞后也有对应的唤醒方法。归根结底，LockSupport时调用Unsafe中的native代码 LockSupport提供park()和unpark()方法实现阻塞线程和解除线程阻塞的过程，LockSupport和每个使用它的线程都有一个许可（Peimit）关联，每个线程都有一个相关的permit，peimit最多只有一个，重复调用unpark也不会积累凭证。 形象理解：线程阻塞需要消耗凭证（Permit），这个凭证最多只有一个 当调用park时，如果有凭证，则会直接消耗掉这个凭证然后正常退出。如果没有凭证，则必须阻塞等待凭证可用； 当调用unpark时，它会增加一个凭证，但凭证最多只能有1各，累加无效。 面试题 为什么LockSupport可以突破wait/notify的原有调用顺序？ 因为unpark获得了一个凭证，之后再调用park方法，就可以名正言顺的凭证消费，故不会阻塞，先发放了凭证后续可以畅通无阻。 为什么唤醒两次后阻塞两次，但最终结果还会阻塞线程？ 因为凭证的数量最多为1，连续调用两次unpark和调用一次unpark效果一样，只会增加一个凭证，而调用两次park却需要消费两个凭证，证不够，不能放行。","categories":[{"name":"JUC并发编程","slug":"JUC并发编程","permalink":"https://gitee.com/yunyd/categories/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"JUC并发编程","slug":"JUC并发编程","permalink":"https://gitee.com/yunyd/tags/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"author":"llllz."},{"title":"说说Java锁事  -3","slug":"说说Java锁事  -3","date":"2023-08-01T01:12:22.000Z","updated":"2023-08-14T14:08:32.252Z","comments":true,"path":"posts/da3e444a.html","link":"","permalink":"https://gitee.com/yunyd/posts/da3e444a.html","excerpt":"","text":"说说Java”锁”事3.1 从轻松的乐观锁和悲观锁开讲●悲观锁： 认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改，synchronized和Lock的实现类都是悲观锁，适合写操作多的场景，先加锁可以保证写操作时数据正确，显示的锁定之后再操作同步资源—–狼性锁 ●乐观锁： 认为自己在使用数据的时候不会有别的线程修改数据或资源，不会添加锁，Java中使用无锁编程来实现，只是在更新的时候去判断，之前有没有别的线程更新了这个数据，如果这个数据没有被更新，当前线程将自己修改的数据成功写入，如果已经被其他线程更新，则根据不同的实现方式执行不同的操作，比如：放弃修改、重试抢锁等等。判断规则有：版本号机制Version，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。—–适合读操作多的场景，不加锁的特性能够使其读操作的性能大幅提升，乐观锁则直接去操作同步资源，是一种无锁算法，得之我幸不得我命—佛系锁 3.2 通过8种情况演示锁运行案例，看看锁到底是什么3.2.1 锁相关的8种案例演示code8种案例演示： class Phone { public synchronized void sendEmail() { try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"------sendEmail\"); } public synchronized void sendSMS() { System.out.println(\"------sendSMS\"); } public void hello() { System.out.println(\"------hello\"); } } /** * 现象描述： * 1 标准访问ab两个线程，请问先打印邮件还是短信？ --------先邮件，后短信 共用一个对象锁 * 2. sendEmail钟加入暂停3秒钟，请问先打印邮件还是短信？---------先邮件，后短信 共用一个对象锁 * 3. 添加一个普通的hello方法，请问先打印普通方法还是邮件？ --------先hello，再邮件 * 4. 有两部手机，请问先打印邮件还是短信？ ----先短信后邮件 资源没有争抢，不是同一个对象锁 * 5. 有两个静态同步方法，一步手机， 请问先打印邮件还是短信？---------先邮件后短信 共用一个类锁 * 6. 有两个静态同步方法，两部手机， 请问先打印邮件还是短信？ ----------先邮件后短信 共用一个类锁 * 7. 有一个静态同步方法 一个普通同步方法，请问先打印邮件还是短信？ ---------先短信后邮件 一个用类锁一个用对象锁 * 8. 有一个静态同步方法，一个普通同步方法，两部手机，请问先打印邮件还是短信？ -------先短信后邮件 一个类锁一个对象锁 */ public class Lock8Demo { public static void main(String[] args) { Phone phone = new Phone(); new Thread(() -&gt; { phone.sendEmail(); }, \"a\").start(); try { TimeUnit.MILLISECONDS.sleep(200); } catch (InterruptedException e) { e.printStackTrace(); } new Thread(() -&gt; { phone.sendSMS(); }, \"b\").start(); } } 结论： 对于普通同步方法，锁的是当前实例对象，通常指this，所有的同步方法用的都是同一把锁—&gt;实例对象本身 对于静态同步方法，锁的时当前类的Class对象 对于同步方法块，锁的时synchronized括号内的对象 3.2.2 synchronized有三种应用方式 作用于实例方法，当前实例加锁，进入同步代码块前要获得当前实例的锁； 作用于代码块，对括号里配置的对象加锁 作用于静态方法，当前类加锁，进去同步代码前要获得当前类对象的锁 3.2.3 从字节码角度分析synchronized实现 javap -c(v附加信息) ***.class 文件反编译 synchronized同步代码块 实现使用的是monitorenter和monitorexit指令 synchronized普通同步方法 调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程会将现持有monitor锁，然后再执行该方法，最后在方法完成（无论是否正常结束）时释放monitor synchronized静态同步方法 ACC_STATIC、ACC_SYNCHRONIZED访问标志区分该方法是否是静态同步方法 3.2.4 反编译synchronized锁的是什么面试题：为什么任何一个对象都可以成为一个锁？ C++源码：ObjectMonitor.java—&gt;ObjectMonitor.cpp—&gt;ObjectMonitor.hpp 每个对象天生都带着一个对象监视器，每一个被锁住的对象都会和Monitor关联起来 总结：指针指向Monitor对象（也称为管程或监视器）的真实地址。每个对象都存在着一个monitor与之关联，当一个monitor被某个线程持有后，它便处于锁定状态。在Java虚拟机（HotSpot）中，monitor是由OnjectMonitor实现的，其主要的数据结构如下（位于HotSpot虚拟机源码ObjectMonitor.hpp文件，C++实现）： 3.2.5 对于Synchronized关键字后面章节详说 3.3 公平锁和非公平锁3.3.1 何为公平锁/非公平锁 公平锁：是指多个线程按照申请锁的顺序来获取锁，这里类似于排队买票，先来的人先买，后来的人再队尾排着，这是公平的—– Lock lock = new ReentrantLock(true)—表示公平锁，先来先得。 非公平锁：是指多个线程获取锁的顺序并不是按照申请的顺序，有可能后申请的线程比先申请的线程优先获取锁，在高并发环境下，有可能造成优先级反转或者饥饿的状态（某个线程一直得不到锁）—- Lock lock = new ReentrantLock(false)—表示非公平锁，后来的也可能先获得锁，默认为非公平锁。 面试题： 为什么会有公平锁/非公平锁的设计？为什么默认非公平？ 恢复挂起的线程到真正锁的获取还是有时间差的，从开发人员来看这个时间微乎其微，但是从CPU的角度来看，这个时间差存在的还是很明显的。所以非公平锁能更充分地利用CPU的时间片，尽量减少CPU空间状态时间。 使用多线程很重要的考量点是线程切换的开销，当采用非公平锁时，当一个线程请求锁获取同步状态，然后释放同步状态，所以刚释放锁的线程在此刻再次获取同步状态的概率就变得很大，所以就减少了线程的开销。 什么时候用公平？什么时候用非公平？ 如果为了更高的吞吐量，很显然非公平锁是比较合适的，因为节省了很多线程切换的时间，吞吐量自然就上去了；否则就用公平锁，大家公平使用。 3.3.2 预埋伏AQS后续深入分析 3.4 可重入锁（递归锁）3.4.1 概念说明是指在同一线程在外层方法获取到锁的时侯，在进入该线程的内层方法会自动获取锁（前提，锁对象的是同一个对象），不会因为之前已经获取过还没释放而阻塞———优点之一就是可一定程度避免死锁。 3.4.2 可重入锁种类 隐式锁（即synchronized关键字使用的锁），默认是可重入锁 在一个synchronized修饰的方法或者代码块的内部调用本类的其他synchronized修饰的方法或者代码块时，是永远可以得到锁。 显式锁（即Lock）也有ReentrantLock这样的可重入锁 隐式和显示可重入锁的演示： public class ReEntryLockDemo { public static void main(String[] args) { final Object o = new Object(); /** * ---------------外层调用 * ---------------中层调用 * ---------------内层调用 */ new Thread(() -&gt; { synchronized (o) { System.out.println(\"---------------外层调用\"); synchronized (o) { System.out.println(\"---------------中层调用\"); synchronized (o) { System.out.println(\"---------------内层调用\"); } } } }, \"t1\").start(); /** * 注意：加锁几次就需要解锁几次 * ---------------外层调用 * ---------------中层调用 * ---------------内层调用 */ Lock lock = new ReentrantLock(); new Thread(() -&gt; { lock.lock(); try { System.out.println(\"---------------外层调用\"); lock.lock(); try { System.out.println(\"---------------中层调用\"); lock.lock(); try { System.out.println(\"---------------内层调用\"); } finally { lock.unlock(); } } finally { lock.unlock(); } } finally { lock.unlock(); } }, \"t2\").start(); } } 3.5 死锁及排查3.5.1 概念死锁是指两个或两个以上的线程在执行过程中，因抢夺资源而造成的一种互相等待的现象，若无外力干涉，则它们无法再继续推进下去。 产生原因： 系统资源不足 进程运行推进顺序不合适 系统资源分配不当 3.5.2 写一个死锁代码case实现死锁： public class DeadLockDemo { static Object a=new Object(); static Object b=new Object(); public static void main(String[] args) { new Thread(() -&gt; { synchronized (a){ System.out.println(\"t1线程持有a锁，试图获取b锁\"); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (b){ System.out.println(\"t1线程获取到b锁\"); } } },\"t1\").start(); new Thread(() -&gt; { synchronized (b){ System.out.println(\"t2线程持有a锁，试图获取a锁\"); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (a){ System.out.println(\"t2线程获取到a锁\"); } } },\"t2\").start(); } } 3.5.3 如何排查死锁 纯命令 jps -l jstack 进程编号 图形化 jconsole 3.6 写锁（独占锁）/读锁（共享锁）深度源码分析见后面 3.7 自旋锁spinLock深度源码分析见后面 3.8 无锁-&gt;独占锁-&gt;读写锁-&gt;邮戳锁深度源码分析见后面 3.9 无锁-&gt;偏向锁-&gt;轻量锁-&gt;重量锁深度源码分析见后面","categories":[{"name":"JUC并发编程","slug":"JUC并发编程","permalink":"https://gitee.com/yunyd/categories/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"JUC并发编程","slug":"JUC并发编程","permalink":"https://gitee.com/yunyd/tags/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"author":"llllz."},{"title":"CompletableFuture  -2","slug":"CompletableFuture  -2","date":"2023-07-28T02:12:22.000Z","updated":"2023-08-14T14:08:38.972Z","comments":true,"path":"posts/1fb3c234.html","link":"","permalink":"https://gitee.com/yunyd/posts/1fb3c234.html","excerpt":"","text":"CompletableFuture2.1 Future接口理论知识复习Future接口（FutureTask实现类）定义了操作异步任务执行一些方法，如获取异步任务的执行结果、取消异步任务的执行、判断任务是否被取消、判断任务执行是否完毕等。 举例：比如主线程让一个子线程去执行任务，子线程可能比较耗时，启动子线程开始执行任务后，主线程就去做其他事情了，忙完其他事情或者先执行完，过了一会再才去获取子任务的执行结果或变更的任务状态（老师上课时间想喝水，他继续讲课不结束上课这个主线程，让学生去小卖部帮老师买水完成这个耗时和费力的任务）。 2.2 Future接口常用实现类FutureTask异步任务2.2.1 Future接口能干什么Future是Java5新加的一个接口，它提供一种异步并行计算的功能，如果主线程需要执行一个很耗时的计算任务，我们会就可以通过Future把这个任务放进异步线程中执行，主线程继续处理其他任务或者先行结束，再通过Future获取计算结果。 2.2.2 Future接口相关架构●目的：异步多线程任务执行且返回有结果，三个特点：多线程、有返回、异步任务（班长为老师去买水作为新启动的异步多线程任务且买到水有结果返回） ●代码实现：Runnable接口+Callable接口+Future接口和FutureTask实现类。 FutureTask开启异步任务： public class CompletableFutureDemo { public static void main(String[] args) throws ExecutionException, InterruptedException { FutureTask&lt;String&gt; futureTask = new FutureTask(new MyThread()); Thread t1 = new Thread(futureTask); //开启一个异步线程 t1.start(); System.out.println(futureTask.get()); //有返回hello Callable } } class MyThread implements Callable&lt;String&gt; { @Override public String call() throws Exception { System.out.println(\"--------come in\"); return \"hello Callable\"; } } 2.2.3 Future编码实战和优缺点分析●优点：Future+线程池异步多线程任务配合，能显著提高程序的运行效率。 ●缺点： ​ ○get()阻塞—一旦调用get()方法求结果，一旦调用不见不散，非要等到结果才会离开，不管你是否计算完成，如果没有计算完成容易程序堵塞。 ​ ○isDone()轮询—轮询的方式会耗费无谓的cpu资源，而且也不见得能及时得到计算结果，如果想要异步获取结果，通常会以轮询的方式去获取结果，尽量不要阻塞。 ●结论：Future对于结果的获取不是很友好，只能通过阻塞或轮询的方式得到任务的结果。 Future获取结果get()和轮询： public class FutureApiDemo { public static void main(String[] args) throws ExecutionException, InterruptedException, TimeoutException { FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(() -&gt; { System.out.println(Thread.currentThread().getName() + \"--------come in\"); try { TimeUnit.SECONDS.sleep(5); } catch (InterruptedException e) { e.printStackTrace(); } return \"task over\"; }); Thread t1 = new Thread(futureTask, \"t1\"); t1.start(); // System.out.println(futureTask.get());//这样会有阻塞的可能，在程序没有计算完毕的情况下。 System.out.println(Thread.currentThread().getName() + \" ------忙其他任务\"); // System.out.println(futureTask.get(3,TimeUnit.SECONDS));//只愿意等待三秒，计算未完成直接抛出异常 while (true) {//轮询 if(futureTask.isDone()){ System.out.println(futureTask.get()); break; }else{ TimeUnit.MILLISECONDS.sleep(500); System.out.println(\"正在处理中，不要催了，越催越慢\"); } } /* 轮询结果 * main ------忙其他任务 t1--------come in 正在处理中，不要催了，越催越慢 正在处理中，不要催了，越催越慢 正在处理中，不要催了，越催越慢 正在处理中，不要催了，越催越慢 正在处理中，不要催了，越催越慢 正在处理中，不要催了，越催越慢 正在处理中，不要催了，越催越慢 正在处理中，不要催了，越催越慢 正在处理中，不要催了，越催越慢 正在处理中，不要催了，越催越慢 task over Process finished with exit code 0 * */ } } 2.2.4 完成一些复杂的任务●对于简单的业务场景使用Future完全ok ●回调通知： ​ ○应对Future的完成时间，完成了可以告诉我，也就是我们的回调通知 ​ ○通过轮询的方式去判断任务是否完成这样非常占cpu并且代码也不优雅 ●创建异步任务：Future+线程池组合 ●多个任务前后依赖可以组合处理（水煮鱼—&gt;买鱼—&gt;调料—&gt;下锅）： ​ ○想将多个异步任务的结果组合起来，后一个异步任务的计算结果需要钱一个异步任务的值 ​ ○想将两个或多个异步计算合并成为一个异步计算，这几个异步计算互相独立，同时后面这个又依赖前一个处理的结果 ●对计算速度选最快的： ​ ○当Future集合中某个任务最快结束时，返回结果，返回第一名处理结果 ●结论： ​ ○使用Future之前提供的那点API就囊中羞涩，处理起来不够优雅，这时候还是让CompletableFuture以声明式的方式优雅的处理这些需求。 ​ ○从i到i++ ​ ○Future能干的，CompletableFuture都能干 2.3 CompletableFuture对Future的改进2.3.1 CompletableFuture为什么会出现●get()方法在Future计算完成之前会一直处在阻塞状态下，阻塞的方式和异步编程的设计理念相违背。 ●isDene()方法容易耗费cpu资源（cpu空转）， ●对于真正的异步处理我们希望是可以通过传入回调函数，在Future结束时自动调用该回调函数，这样，我们就不用等待结果 jdk8设计出CompletableFuture，CompletableFuture提供了一种观察者模式类似的机制，可以让任务执行完成后通知监听的一方。 2.3.2 CompletableFuture和CompletionStage介绍类架构说明： ●接口CompletionStage ​ ○代表异步计算过程中的某一个阶段，一个阶段完成以后可能会触发另外一个阶段。 ​ ○一个阶段的执行可能是被单个阶段的完成触发，也可能是由多个阶段一起触发 ●类CompletableFuture ​ ○提供了非常强大的Future的扩展功能，可以帮助我们简化异步编程的复杂性，并且提供了函数式编程的能力，可以通过回调的方式处理计算结果，也提供了转换和组合CompletableFuture的方法 ​ ○它可能代表一个明确完成的Future，也可能代表一个完成阶段（CompletionStage），它支持在计算完成以后触发一些函数或执行某些动作 2.3.3 核心的四个静态方法，来创建一个异步任务四个静态构造方法 对于上述Executor参数说明：若没有指定，则使用默认的ForkJoinPoolcommonPool（）作为它的线程池执行异步代码，如果指定线程池，则使用我们自定义的或者特别指定的线程池执行异步代码 四个静态方法演示: public class CompletableFutureBuildDemo { public static void main(String[] args) throws ExecutionException, InterruptedException { ExecutorService executorService = Executors.newFixedThreadPool(3); CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(() -&gt; { System.out.println(Thread.currentThread().getName()); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } },executorService); System.out.println(completableFuture.get()); //null CompletableFuture&lt;String&gt; objectCompletableFuture = CompletableFuture.supplyAsync(()-&gt;{ System.out.println(Thread.currentThread().getName()); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } return \"hello supplyAsync\"; },executorService); System.out.println(objectCompletableFuture.get());//hello supplyAsync executorService.shutdown(); } } CompletableFuture减少阻塞和轮询，可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法。 CompletableFuture使用演示: public class CompletableFutureUseDemo { public static void main(String[] args) throws ExecutionException, InterruptedException { ExecutorService executorService = Executors.newFixedThreadPool(3); CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; { System.out.println(Thread.currentThread().getName() + \"---come in\"); int result = ThreadLocalRandom.current().nextInt(10); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } if (result &gt; 5) { //模拟产生异常情况 int i = 10 / 0; } System.out.println(\"----------1秒钟后出结果\" + result); return result; }, executorService).whenComplete((v, e) -&gt; { if (e == null) { System.out.println(\"计算完成 更新系统\" + v); } }).exceptionally(e -&gt; { e.printStackTrace(); System.out.println(\"异常情况：\" + e.getCause() + \" \" + e.getMessage()); return null; }); System.out.println(Thread.currentThread().getName() + \"先去完成其他任务\"); executorService.shutdown(); } } /** * 无异常情况 * pool-1-thread-1---come in * main先去完成其他任务 * ----------1秒钟后出结果9 * 计算完成 更新系统9 */ /** * 有异常情况 *pool-1-thread-1---come in * main先去完成其他任务 * java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zero * 异常情况：java.lang.ArithmeticException: / by zero java.lang.ArithmeticException: / by zero */ CompletableFuture优点： ●异步任务结束时，会自动回调某个对象的方法 ●主线程设置好回调后，不用关心异步任务的执行，异步任务之间可以顺序执行 ●异步任务出错时，会自动回调某个对象的方法 2.4 案例精讲-从电商网站的比价需求展开2.4.1 函数式编程已成为主流Lambda表达式+Stream流式调用+Chain链式调用+Java8函数式编程 函数时接口： ●Runnable：无参数、无返回值 ●Function：接受一个参数，并且有返回值 ●Consumer：接受一个参数，没有返回值 ​ ○BiConsumer：接受两个参数，没有返回值 ●Supplier：没有参数，有返回值 小结： chain链式调用： public class CompletableFutureMallDemo { public static void main(String[] args) { Student student = new Student(); student.setId(1).setStudentName(\"z3\").setMajor(\"english\"); //链式调用 } } @AllArgsConstructor @NoArgsConstructor @Data @Accessors(chain = true)//开启链式调用 class Student { private Integer id; private String studentName; private String major; } 2.4.2 大厂业务需求说明切记：功能—&gt;性能（完成—&gt;完美） 电商网站比价需求分析： 1.需求说明： ​ a同一款产品，同时搜索出同款产品在各大电商平台的售价 ​ b同一款产品，同时搜索出本产品在同一个电商平台下，各个入驻卖家售价是多少 2.输出返回： ​ a出来结果希望是同款产品的在不同地方的价格清单列表，返回一个List ​ 例如：《Mysql》 in jd price is 88.05 《Mysql》 in taobao price is 90.43 3.解决方案，对比同一个产品在各个平台上的价格，要求获得一个清单列表 astep by step，按部就班，查完淘宝查京东，查完京东查天猫…. ball in，万箭齐发，一口气多线程异步任务同时查询 2.4.3 一波流Java8函数式编程带走-比价案例实战Case比价实战Case: public class CompletableFutureMallDemo { static List&lt;NetMall&gt; list = Arrays.asList(new NetMall(\"jd\"), new NetMall(\"taobao\"), new NetMall(\"dangdang\")); /** * step by step * @param list * @param productName * @return */ public static List&lt;String&gt; getPrice(List&lt;NetMall&gt; list, String productName) { //《Mysql》 in jd price is 88.05 return list .stream() .map(netMall -&gt; String.format(\"《\" + productName + \"》\" + \"in %s price is %.2f\", netMall.getNetMallName(), netMall.calcPrice(productName))) .collect(Collectors.toList()); } /** * all in * 把list里面的内容映射给CompletableFuture() * @param list * @param productName * @return */ public static List&lt;String&gt; getPriceByCompletableFuture(List&lt;NetMall&gt; list, String productName) { return list.stream().map(netMall -&gt; CompletableFuture.supplyAsync(() -&gt; String.format(\"《\" + productName + \"》\" + \"in %s price is %.2f\", netMall.getNetMallName(), netMall.calcPrice(productName)))) //Stream&lt;CompletableFuture&lt;String&gt;&gt; .collect(Collectors.toList()) //List&lt;CompletableFuture&lt;String&gt;&gt; .stream()//Stream&lt;String&gt; .map(s -&gt; s.join()).collect(Collectors.toList()); //List&lt;String&gt; } public static void main(String[] args) { /** * 采用step by setp方式查询 * 《masql》in jd price is 110.11 * 《masql》in taobao price is 109.32 * 《masql》in dangdang price is 109.24 * ------costTime: 3094 毫秒 */ long StartTime = System.currentTimeMillis(); List&lt;String&gt; list1 = getPrice(list, \"masql\"); for (String element : list1) { System.out.println(element); } long endTime = System.currentTimeMillis(); System.out.println(\"------costTime: \" + (endTime - StartTime) + \" 毫秒\"); /** * 采用 all in三个异步线程方式查询 * 《mysql》in jd price is 109.71 * 《mysql》in taobao price is 110.69 * 《mysql》in dangdang price is 109.28 * ------costTime1009 毫秒 */ long StartTime2 = System.currentTimeMillis(); List&lt;String&gt; list2 = getPriceByCompletableFuture(list, \"mysql\"); for (String element : list2) { System.out.println(element); } long endTime2 = System.currentTimeMillis(); System.out.println(\"------costTime\" + (endTime2 - StartTime2) + \" 毫秒\"); } } @AllArgsConstructor @NoArgsConstructor @Data class NetMall { private String netMallName; public double calcPrice(String productName) { try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } return ThreadLocalRandom.current().nextDouble() * 2 + productName.charAt(0); } } 2.4.4 CompletableFuture常用方法●获得结果和触发计算 ​ ○获取结果 ​ ■public T get() ​ ■public T get(long timeout,TimeUnit unit) ​ ■public T join() —&gt;和get一样的作用，只是不需要抛出异常 ​ ■public T getNow(T valuelfAbsent) —&gt;计算完成就返回正常值，否则返回备胎值（传入的参数），立即获取结果不阻塞 ​ ○主动触发计算 ​ ■public boolean complete(T value) —-&gt;是否打断get方法立即返回括号值 ●对计算结果进行处理 ​ ○thenApply —&gt;计算结果存在依赖关系，这两个线程串行化—-&gt;由于存在依赖关系（当前步错，不走下一步），当前步骤有异常的话就叫停 ​ ○handle —&gt;计算结果存在依赖关系，这两个线程串行化—-&gt;有异常也可以往下走一步 对计算结果进行处理演示: public class CompletableFutureApiDemo { public static void main(String[] args) throws ExecutionException, InterruptedException, TimeoutException { ExecutorService threadPool = Executors.newFixedThreadPool(3); CompletableFuture&lt;Integer&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; { try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } return 1; }, threadPool).thenApply(f -&gt; { System.out.println(\"222\"); return f + 2; }).handle((f, e) -&gt; { System.out.println(\"3333\"); int i=10/0; return f + 2; // thenApply(f -&gt; { // System.out.println(\"3333\"); // return f + 2; }).whenComplete((v, e) -&gt; { if (e == null) { System.out.println(\"----计算结果\" + v); } }).exceptionally(e -&gt; { e.printStackTrace(); System.out.println(e.getCause()); return null; }); System.out.println(Thread.currentThread().getName() + \"------主线程先去做其他事情\"); } } ●对计算结果进行消费 ​ ○接受任务的处理结果，并消费处理，无返回结果 ​ ○thenAccept thenAccetp演示: public class CompletableFutureApi2Demo { public static void main(String[] args) { ExecutorService threadPool = Executors.newFixedThreadPool(3); CompletableFuture.supplyAsync(() -&gt; { return 1; }, threadPool).thenApply(f -&gt; { return f + 2; }).thenApply(f -&gt; { return f + 2; }).thenAccept(r -&gt; { System.out.println(r);//5 }); } } ​ ○对比补充 ​ ■thenRun(Runnable runnable) :任务A执行完执行B，并且不需要A的结果 ​ ■thenAccept(Consumer action): 任务A执行完执行B，B需要A的结果，但是任务B没有返回值 ​ ■thenApply(Function fn): 任务A执行完执行B，B需要A的结果，同时任务B有返回值 对比补充: public class CompletableFutureApi2Demo { public static void main(String[] args) { System.out.println(CompletableFuture.supplyAsync(() -&gt; \"result\").thenRun(() -&gt; {}).join());//null System.out.println(CompletableFuture.supplyAsync(() -&gt; \"result\").thenAccept(r -&gt; System.out.println(r)).join());//result null System.out.println(CompletableFuture.supplyAsync(() -&gt; \"result\").thenApply(f -&gt; f + 2).join());//result2 } } ​ ○CompletableFuture和线程池说明 ​ ■如果没有传入自定义线程池，都用默认线程池ForkJoinPool ​ ■传入一个线程池，如果你执行第一个任务时，传入了一个自定义线程池 ●调用thenRun方法执行第二个任务时，则第二个任务和第一个任务时共用同一个线程池 ●调用thenRunAsync执行第二个任务时，则第一个任务使用的是你自定义的线程池，第二个任务使用的是ForkJoin线程池 ​ ■备注：可能是线程处理太快，系统优化切换原则， 直接使用main线程处理，thenAccept和thenAcceptAsync，thenApply和thenApplyAsync等，之间的区别同理。 ●对计算速度进行选用 ​ ○谁快用谁 ​ ○applyToEither applyToEither演示: public class CompletableFutureApiDemo { public static void main(String[] args) { ExecutorService threadPool = Executors.newFixedThreadPool(3); CompletableFuture&lt;String&gt; playA = CompletableFuture.supplyAsync(() -&gt; { try { System.out.println(\"A come in\"); TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); } return \"playA\"; }, threadPool); CompletableFuture&lt;String&gt; playB = CompletableFuture.supplyAsync(() -&gt; { try { System.out.println(\"B come in\"); TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); } return \"playB\"; }, threadPool); CompletableFuture&lt;String&gt; result = playA.applyToEither(playB, f -&gt; { return f + \" is winner\"; }); /** * A come in * B come in * main-----------winner:playA is winner */ System.out.println(Thread.currentThread().getName() + \"-----------winner:\" + result.join()); } } ●对计算结果进行合并 ​ ○两个CompletableStage任务都完成后，最终能把两个任务的结果一起交给thenCombine来处理 ​ ○先完成的先等着，等待其他分支任务 thenCombine演示: public class CompletableFutureApi3Demo { public static void main(String[] args) { CompletableFuture&lt;Integer&gt; completableFuture1 = CompletableFuture.supplyAsync(() -&gt; { System.out.println(Thread.currentThread().getName() + \" 启动\"); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } return 10; }); CompletableFuture&lt;Integer&gt; completableFuture2 = CompletableFuture.supplyAsync(() -&gt; { System.out.println(Thread.currentThread().getName() + \" 启动\"); try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); } return 20; }); CompletableFuture&lt;Integer&gt; finalResult = completableFuture1.thenCombine(completableFuture2, (x, y) -&gt; { System.out.println(\"----------开始两个结果合并\"); return x + y; }); System.out.println(finalResult.join()); } }","categories":[{"name":"JUC并发编程","slug":"JUC并发编程","permalink":"https://gitee.com/yunyd/categories/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"JUC并发编程","slug":"JUC并发编程","permalink":"https://gitee.com/yunyd/tags/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"author":"llllz."},{"title":"线程基础知识复习  -1","slug":"线程基础知识复习  -1","date":"2023-07-26T05:12:22.000Z","updated":"2023-08-14T14:08:25.638Z","comments":true,"path":"posts/5e115804.html","link":"","permalink":"https://gitee.com/yunyd/posts/5e115804.html","excerpt":"","text":"线程基础知识复习● 1把锁：synchronized（后面细讲） ● 2个并： ​ ○并发（concurrent）：是在同一实体上的多个事件，是在一台机器上“同时”处理多个任务，同一时刻，其实是只有一个事情再发生。 ​ ○并行（parallel）：是在不同实体上的多个事件，是在多台处理器上同时处理多个任务，同一时刻，大家都在做事情，你做你的，我做我的，各干各的。 ●3个程： ​ ○进程：在系统中运行的一个应用程序，每个进程都有它自己的内存空间和系统资源 ​ ○线程：也被称为轻量级进程，在同一个进程内会有1个或多个线程，是大多数操作系统进行时序调度的基本单元。 ​ ○管程：Monitor（锁），也就是我们平时所说的锁。Monitor其实是一种同步机制，它的义务是保证（同一时间）只有一个线程可以访问被保护的数据和代码，JVM中同步是基于进入和退出监视器（Monitor管程对象）来实现的，每个对象实例都会有一个Monitor对象，Monitor对象和Java对象一同创建并销毁，底层由C++语言实现。 ●线程分类（一般不做特别说明配置，默认都是用户线程）： ​ ○用户线程：是系统的工作线程，它会完成这个程序需要完成的业务操作。 ​ ○守护线程：是一种特殊的线程为其他线程服务的，在后台默默地完成一些系统性的任务，比如垃圾回收线程就是最典型的例子。守护线程作为一个服务线程，没有服务对象就没有必要继续运行了，如果用户线程全部结束了，意味着程序需要完成的业务操作已经结束了，系统可以退出了。所以假如当系统只剩下守护线程的时候，守护线程伴随着JVM一同结束工作。 守护线程代码实操 Java 代码 public class DaemonDemo { ​ public static void main(String[] args) { ​ Thread t1 = new Thread(() -&gt; { ​ System.out.println(Thread.currentThread().getName() + \" 开始运行,\" + (Thread.currentThread().isDaemon() ? \"守护线程\" : \"用户线程\")); ​ while (true) { ​ } ​ }, \"t1\"); ​ t1.setDaemon(true);//通过设置属性Daemon来设置当前线程是否为守护线程 ​ t1.start(); ​ try { ​ TimeUnit.SECONDS.sleep(3); ​ } catch (InterruptedException e) { ​ e.printStackTrace(); ​ } ​ System.out.println(Thread.currentThread().getName() + \" 主线程结束\"); ​ } } 输出：t1 开始运行,守护线程 main 主线程结束---&gt;在main主线程结束后，守护线程会伴随着JVM一同结束工作，即使还有循环没有结束","categories":[{"name":"JUC并发编程","slug":"JUC并发编程","permalink":"https://gitee.com/yunyd/categories/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"JUC并发编程","slug":"JUC并发编程","permalink":"https://gitee.com/yunyd/tags/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}],"author":"llllz."},{"title":"Linux","slug":"Linux","date":"2023-07-26T03:00:36.000Z","updated":"2023-08-13T11:35:58.948Z","comments":true,"path":"posts/53d0684b.html","link":"","permalink":"https://gitee.com/yunyd/posts/53d0684b.html","excerpt":"","text":"Linux基础命令Linux的目录结构 /，根目录是最顶级的目录了 Linux只有一个顶级目录：/ 路径描述的层次关系同样适用/来表示 /home/itheima/a.txt，表示根目录下的home文件夹内有itheima文件夹，内有a.txt 开放端口 开放80端口 firewall-cmd –zone=public –add-port=80/tcp –permanent 重启firewall firewall-cmd –reload 查看开放的端口 firewall-cmd –list-ports 返回刚才的目录 cd - 图形化界面与命令行模式的切换 systemctl set-default graphical.target //设置开机启动自动由命令行模式更改为图形界面模式 systemctl set-default multi-user.target //设置开机启动自动由图形界面模式更改为命令行模式 init 0 //关机 init 3 //由图形化界面切换到命令行界面 init 5 //由命令行界面切换到图形化界面 init 6 或 reboot //重启 防火墙 systemctl status firewalld 查看当前防火墙状态 systemctl stop firewalld.service 关闭防火墙 systemctl disable firewalld.service 禁止开机自启防火墙 systemctl start firewalld.service 打开防火墙 Linux命令行上面查看命令的用法命令 –help ls命令功能：列出文件夹信息 语法：ls [-l -h -a] [参数] 参数：被查看的文件夹，不提供参数，表示查看当前工作目录 -l，以列表形式查看 -h，配合-l，以更加人性化的方式显示文件大小 -a，显示隐藏文件 隐藏文件、文件夹在Linux中以.开头的，均是隐藏的。 默认不显示出来，需要-a选项才可查看到。 pwd命令功能：展示当前工作目录 语法：pwd cd命令功能：切换工作目录 语法：cd [目标目录] 参数：目标目录，要切换去的地方，不提供默认切换到当前登录用户HOME目录 HOME目录每一个用户在Linux系统中都有自己的专属工作目录，称之为HOME目录。 普通用户的HOME目录，默认在：/home/用户名 root用户的HOME目录，在：/root FinalShell登陆终端后，默认的工作目录就是用户的HOME目录 相对路径、绝对路径 相对路径，==非==/开头的称之为相对路径 相对路径表示以当前目录作为起点，去描述路径，如test/a.txt，表示当前工作目录内的test文件夹内的a.txt文件 绝对路径，==以==/开头的称之为绝对路径 绝对路径从根开始描述路径 特殊路径符 .，表示当前，比如./a.txt，表示当前文件夹内的a.txt文件 ..，表示上级目录，比如../表示上级目录，../../表示上级的上级目录 ~，表示用户的HOME目录，比如cd ~，即可切回用户HOME目录 nohup命令英文全称：no hang up（不挂起），用于不挂断地运行指定命令，退出终端不会影响程序的运行； 语法格式：nohup Command [Arg …] [&amp;] 参数说明： Command：要执行的命令 Arg：一些参数，可以指定输出文件 &amp;：让命令在后台运行 举例： nohup java -jar boot工程.jar &amp;&gt; hello.log &amp; 后台运行java -jar命令，并将日志输出到hello.log文件,hello.log文件会在当前目录下面生成 mkdir命令功能：创建文件夹 语法：mkdir [-p] 参数 参数：被创建文件夹的路径（相对、绝对、特殊路径符都可以使用） mkdir /home/test mkdir test01 选项：-p，可选，表示创建前置路径（表示自动创建不存在的父目录，适用于创建连续多层级的目录） mkdir -p itliu/good/666（如果不用-p的话，会报错，因为没有itliu和good的文件夹） 注意：如果是普通用户的话，创建文件夹需要修改权限，只能在HOME目录内才可以创建文件夹，在HOME目录外创建文件夹需要权限，root用户才可以 touch命令功能：创建文件 语法：touch 参数 touch test 参数：被创建的文件路径（相对、绝对、特殊路径符都可以使用） cat命令功能：查看文件内容 语法：cat 参数 参数：被查看的文件路径（相对、绝对、特殊路径符都可以使用） more命令功能：查看文件，可以支持翻页查看 语法：more 参数 参数：被查看的文件路径（相对、绝对、特殊路径符都可以使用） 在查看过程中： 空格键翻页 q退出查看 cp命令功能：复制文件、文件夹 语法：cp [-r] 参数1 参数2 参数1，被复制的 参数2，要复制去的地方 选项：-r，可选，复制文件夹使用 示例： cp a.txt b.txt，复制当前目录下a.txt为b.txt cp a.txt test/，复制当前目录a.txt到test文件夹内 cp -r test test2，复制文件夹test及test下面的所有文件到当前文件夹内为test2存在 cp -r test/. test2 表示将test下的文件复制到test2,不包括test目录 mv命令功能：移动文件、文件夹 语法：mv 参数1 参数2 参数1：Linux路径，被移动的文件或者文件夹 参数2：Linux路径，要移动去的地方，参数2如果不存在，则会进行改名 mv test01.txt test02.txt(将test01.txt改名为test02.txt) rm命令功能：删除文件、文件夹 语法：rm [-r -f] 参数1 参数2....参数N 参数：支持多个，每一个表示被删除的，空格进行分隔(可以用绝对，相对，特殊路径)（/root/test） 选项：-r，删除文件夹使用 选项：-f，强制删除，不会给出确认提示，一般root用户会用到 rm命令支持通配符*，用来做模糊匹配 符号*表示通配符， 即匹配任意内容（包含空），示例： test*，表示匹配任何以test开头 的内容 *test，表示匹配任何以test结尾的内容 *test *，表示匹配任何包含test的内容 rm命令很危险，一定要注意，特别是切换到root用户的时候。 which命令功能：查看命令的程序本体文件路径，前面学习的Linux命令，其实它们的本体就是一个个的二进制可执行程序，和Windows系统中的.exe文件，是一个意思。可以通过which命令，查看所使用的一系列命令的程序文件存放在哪里 语法：which 参数 参数：被查看的命令 例： [itliu@bogon ~]which cd /usr/bin/cd [itliu@bogon ~]which pwd /usr/bin/pwd find命令功能：按名称搜索文件 语法1按文件名搜索：find 路径 -name 参数(“被查找的文件名或者目录”) 路径，搜索的起始路径 参数，搜索的关键字，支持通配符*， 比如：*test表示搜索任意以test结尾的文件 功能：按文件大小查找文件 语法：find 其实路径 -size +|-n[kMG] +、-表示大于和小于 n表示大小数字 kMG表示大单位，k（小写字母）表示kb，M表示MB，G表示GB 示例： 查找小于10KB的文件：find / -size -10k 查找大于100MB的文件: find /-size +100M 查找大于1GB的文件: fing / -size +1G grep命令功能：过滤关键字 语法：grep [-n] 关键字 文件路径 选项-n，可选，表示在结果中显示匹配的行的行号。 参数，关键字，必填，表示过滤的关键字，带有空格或其它特殊符号，建议使用””将关键字包围起来 参数，文件路径，必填，表示要过滤内容的文件路径，可作为内容输入端口 grep “itheima” test.txt grep -n “itheima” test.txt 参数文件路径，可以作为管道符的输入 wc命令功能：统计 语法：wc [-c -m -l -w] 文件路径 选项，-c，统计bytes数量 选项，-m，统计字符数量 选项，-l，统计行数 选项，-w，统计单词数量 参数，文件路径，被统计的文件，可作为内容输入端口 wc test.txt 参数文件路径，可作为管道符的输入 管道符|写法：| 功能：将符号左边命令的结果，作为符号右边命令的输入 示例： cat a.txt | grep itheima，将cat a.txt的结果，作为grep命令的输入，用来过滤itheima关键字 cat a.txt | grep itheima 等同于 grep itheima a.txt cat a.txt | wc -l 等同于 wc -l a.txt 可以支持嵌套： cat a.txt | grep itheima | grep itcast 执行流程：首先cat a.txt | grep itheima ，然后将cat a.txt | grep itheima的结果作为grep itcast命令的输入 管道符左边的命令不一定只能是cat，只要是能产生内容输出的命令，都可以跟管道符做配合。比如ls命令，也有输出 例如： ls | grep test 这样就可以在当前目录里面的所有文件夹过滤出test的文件夹 ls /usr/bin | grep gtf 可以在/usr/bin目录下面，只输出gtf，过滤掉出gtf外所有的文件 ls -l /usr/bin | grep gtf ls -l /usr/bin | wc -l 统计出/usr/bin目录下面共计多少行 echo命令功能：输出内容 语法：echo 参数 参数：被输出的内容,带有空格或者\\等特殊符号，建议使用双引号包围（因为不包围的话，空格后很容易被识别为参数2，尽管 echo不受影响，但是要养成习惯 echo “Hello World” `反引号功能：被两个反引号包围的内容，会作为命令执行 ``这个符号位于Esc下面与~符号在一起 示例： echo `pwd`，会输出当前工作目录 重定向符 &gt;,将左侧命令的结果，覆盖写入到符号右侧指定的文件中 &gt;&gt;,将左侧命令的结果，追加写入到符号右侧指定的文件中 演示： 先执行echo “Hello Linux” &gt; itheima.txt 再执行echo “Hello itheima” &gt;itheima.txt，覆盖新内容 再次执行echo “Hello itcast” &gt;&gt; itheima.txt，使用&gt;&gt;追加新内容 &gt;和&gt;&gt;的使用，只要是左面产生结果的，可以将符号左面命令的结果，直接覆盖或追加到右面的文件中 tail命令功能：查看文件尾部内容 语法：tail [-f -num] 参数 参数：Linux路径，表示被查看的文件 选项：-f，持续跟踪文件修改 选项: -num,表示查看尾部多少行，不填默认10行 tail test.txt(默认查看尾部10的内容) tail -5 test.txt(查看尾部5行的内容) tail -f test.txt(默认查看尾部10行的内容，并且程序继续运行，此时对当前finalshell右键，复制一个标签，相当于新连接一个窗口，在那个窗口继续使用命令例如：echo “hello dajiahao” &gt;&gt; test.txt,这个命令执行完毕后，此时再打开之前那个标签窗口，会新显示你刚写的内容)如果想停止的话直接ctrl+c head命令功能：查看文件头部内容 语法：head [-n] 参数 参数：被查看的文件 选项：-n，查看的行数 vi编辑器命令模式快捷键 退出搜索模式：noh 底线命令快捷键 命令的选项我们学习的一系列Linux命令，它们所拥有的选项都是非常多的。 比如，简单的ls命令就有：-a -A -b -c -C -d -D -f -F -g -G -h -H -i -I -k -l -L -m -n -N -o -p -q -Q -r-R -s -S -t -T -u -U -v -w -x -X -1等选项，可以发现选项是极其多的。 课程中， 并不会将全部的选项都进行讲解，否则，一个ls命令就可能讲解2小时之久。 课程中，会对常见的选项进行讲解， 足够满足绝大多数的学习、工作场景。 查看命令的帮助可以通过：命令 --help查看命令的帮助手册 查看命令的详细手册可以通过：man 命令查看某命令的详细手册 Linux常用操作软件安装 CentOS系统使用： yum [install remove search] [-y] 软件名称 install 安装 remove 卸载 search 搜索 -y，自动确认 Ubuntu系统使用 apt [install remove search] [-y] 软件名称 install 安装 remove 卸载 search 搜索 -y，自动确认 yum 和 apt 均需要root权限 systemctl功能：控制系统服务的启动关闭等 语法：systemctl start | stop | restart | disable | enable | status 服务名 start，启动 stop，停止 status，查看状态 disable，关闭开机自启 enable，开启开机自启 restart，重启 软链接功能：创建文件、文件夹软链接（快捷方式） 语法：ln -s 参数1 参数2 参数1：被链接的（需要使用绝对路径） 参数2：要链接去的地方（快捷方式的名称和存放位置） 日期语法：date [-d] [+格式化字符串] -d 按照给定的字符串显示日期，一般用于日期计算 格式化字符串：通过特定的字符串标记，来控制显示的日期格式 %Y 年%y 年份后两位数字 (00..99) %m 月份 (01..12) %d 日 (01..31) %H 小时 (00..23) %M 分钟 (00..59) %S 秒 (00..60) %s 自 1970-01-01 00:00:00 UTC 到现在的秒数 示例： 按照2022-01-01的格式显示日期 按照2022-01-01 10:00:00的格式显示日期 -d选项日期计算 支持的时间标记为： 时区修改时区为中国时区 ntp功能：同步时间 安装：yum install -y ntp 启动管理：systemctl start | stop | restart | status | disable | enable ntpd 手动校准时间：ntpdate -u ntp.aliyun.com ip地址格式：a.b.c.d abcd为0~255的数字 特殊IP： 127.0.0.1，表示本机 0.0.0.0 可以表示本机 也可以表示任意IP（看使用场景） 查看ip：ifconfig 主机名功能：Linux系统的名称 查看：hostname 设置：hostnamectl set-hostname 主机名 配置VMware固定IP 修改VMware网络，参阅PPT，图太多 设置Linux内部固定IP 修改文件：/etc/sysconfig/network-scripts/ifcfg-ens33 示例文件内容： TYPE=\"Ethernet\" PROXY_METHOD=\"none\" BROWSER_ONLY=\"no\" BOOTPROTO=\"static\" # 改为static，固定IP DEFROUTE=\"yes\" IPV4_FAILURE_FATAL=\"no\" IPV6INIT=\"yes\" IPV6_AUTOCONF=\"yes\" IPV6_DEFROUTE=\"yes\" IPV6_FAILURE_FATAL=\"no\" IPV6_ADDR_GEN_MODE=\"stable-privacy\" NAME=\"ens33\" UUID=\"1b0011cb-0d2e-4eaa-8a11-af7d50ebc876\" DEVICE=\"ens33\" ONBOOT=\"yes\" IPADDR=\"192.168.88.131\" # IP地址，自己设置，要匹配网络范围 NETMASK=\"255.255.255.0\" # 子网掩码，固定写法255.255.255.0 GATEWAY=\"192.168.88.2\" # 网关，要和VMware中配置的一致 DNS1=\"192.168.88.2\" # DNS1服务器，和网关一致即可 ps命令功能：查看进程信息 语法：ps -ef，查看全部进程信息，可以搭配grep做过滤：ps -ef | grep xxx kill命令 nmap命令 netstat命令功能：查看端口占用，或者进程占用哪个端口 用法：netstat -anp | grep xxx netstat -anp | grep 12345 (如果命令执行完毕后，没有任何结果，就说明没有12345这个进程，并且12345这个端口也没有人占用) ping命令测试网络是否联通 语法：ping [-c num] 参数 wget命令 curl命令 top命令功能：查看主机运行状态 语法：top，查看基础信息 可用选项： 交互式模式中，可用快捷键： df命令查看磁盘占用 iostat命令查看CPU、磁盘的相关信息 sar命令查看网络统计 环境变量 临时设置：export 变量名=变量值 永久设置： 针对用户，设置用户HOME目录内：.bashrc文件 针对全局，设置/etc/profile PATH变量记录了执行程序的搜索路径 可以将自定义路径加入PATH内，实现自定义命令在任意地方均可执行的效果 $符号可以取出指定的环境变量的值 语法：$变量名 示例： echo $PATH，输出PATH环境变量的值 echo ${PATH}ABC，输出PATH环境变量的值以及ABC 如果变量名和其它内容混淆在一起，可以使用${} rz、sz命令rz、sz命令需要安装。可以通过：yum -y install lrzsz，即可安装 rz命令，进行上传，语法：直接输入rz即可 sz命令进行下载，语法：sz 要下载的文件 文件会自动下载到桌面的fsdownload文件夹中 压缩解压Linux和Mac系统常用有2种压缩格式，后缀名分别是： .tar 称之为tarball，归档文件，即简单的将文件组装到一个.tar的文件内，并没有太多文件体积的减少，仅仅是简单的封装 .gz，也常见为.tar.gz，gzip格式压缩文件，即使用gzip压缩算法将文件解压到一个文件内，可以极大地减少压缩后的体积 针对这两种格式，使用tar命令均可以进行压缩和解压缩的操作 语法： tar [-c -v -x- f- z- C] 参数1 参数2 … 参数N -c，创建压缩文件，用于压缩模式 -v，显示压缩、解压过程，用于查看进度 -x，解压模式 -f，要创建的文件，或要解压的文件，-f选项必须在所有选项中位置处于最后一个 -z，gzip模式，不使用-z就是普通的tarball格式 -C，选择解压的目的地，用于解压模式 压缩tar -zcvf 压缩包 被压缩1...被压缩2...被压缩N -z表示使用gzip，可以不写 tar -cvf test.tar 1.txt 2.txt 3.txt 将1.txt 2.txt 3.txt压缩到test.tar文件内 tar -zcvf test.tar 1.txt 2.txt 3.txt 将1.txt 2.txt 3.txt压缩到test.tar.gz文件内,使用gzip模式 zip [-r] 参数1 参数2 参数N 解压tar -zxvf 被解压的文件 -C 要解压去的地方 -z表示使用gzip，可以省略 -C，可以省略，指定要解压去的地方，不写解压到当前目录 unzip [-d] 参数 su命令切换用户 语法：su [-] [用户] sudo命令 比如： itheima ALL=(ALL) NOPASSWD: ALL 在visudo内配置如上内容，可以让itheima用户，无需密码直接使用sudo 查看权限控制信息 序号1，表示文件、文件夹的权限控制信息 序号2，表示文件、文件夹所属用户 序号3，表示文件、文件夹所属用户组 权限信息共十位 第1位 第二位内容（-或d或l） -表示文件 d表示文件夹 l表示软链接 第2-4位 第2位内容（r或-） 第3位内容（w或-） 第4位内容（x或-） -表示无此权限 第5-7位 第5位内容（r或-） 第6位内容（w或-） 第7位内容（x或-） -表示无此权限 第8-10位 第8位内容（r或-） 第9位内容（w或-） 第10位内容（x或-） -表示无此权限 rwx分别代表什么 r,针对文件可以查看文件内容 针对文件夹，可以查看文件夹内容，如ls命令 w，针对文件表示可以修改此文件 针对文件夹，可以在文件夹内：创建、删除、改名等操作 x，针对文件表示可以将文件作为程序执行 针对文件夹，表示可以更改目录到此文件夹，即cd进入 chmod命令修改文件、文件夹权限 语法：chmod [-R] 权限 参数 权限，要设置的权限，比如755，表示：rwxr-xr-x 参数，被修改的文件、文件夹 选项-R，设置文件夹和其内部全部内容一样生效 chmod u=rwx,g=rx,o=x hello.txt，将文件权限修改为：rwxr-x–x 其中：u表示user所属用户权限，g表示group组权限，o表示other其它用户权限 chmod-R u=rwx，g=rx,o=x test，将文件夹test以及文件夹内全部内容权限设置为:rwxr-x–x chown命令修改文件、文件夹所属用户、组 语法：chown [-R] [用户][:][用户组] 文件或文件夹 用户组管理 用户管理 getent命令 getent group，查看系统全部的用户组 getent passwd，查看系统全部的用户 env命令查看系统全部的环境变量 语法：env 常用快捷命令 ctrl + c 强制退出 ctrl + d 退出或登出 （不能用于vi/vim） history查看历史输入过的命令 history | grep ls （过滤出历史输入过的ls命令） ctrl + r 输入内容去匹配历史命令 如果搜索到的内容是你需要的，那么： 回车键可以直接执行 键盘左键或者右键，可以得到此命令（不执行） 光标移动快捷键 ctrl + a 跳到命令开头 ctrl + e 跳到命令结尾 ctrl + 键盘左键，向左跳一个单词 ctrl + 键盘右键，向右跳一个单词 清屏 通过快捷键ctrl + l 可以清空终端内容 或通过命令clear得到同样的效果","categories":[{"name":"Linux","slug":"Linux","permalink":"https://gitee.com/yunyd/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://gitee.com/yunyd/tags/Linux/"}],"author":"llllz."},{"title":"大家好","slug":"大家好","date":"2023-07-21T01:01:22.000Z","updated":"2023-08-12T06:47:21.957Z","comments":true,"path":"posts/42adfbca.html","link":"","permalink":"https://gitee.com/yunyd/posts/42adfbca.html","excerpt":"","text":"大家好在Hexo部署时会默认渲染source下的所有html页面，但有时候想在Hexo博客上单独自定义html页面或README.md时，却不希望被Hexo渲染。大家好大家好大家好大家好大家好","categories":[{"name":"打招呼","slug":"打招呼","permalink":"https://gitee.com/yunyd/categories/%E6%89%93%E6%8B%9B%E5%91%BC/"}],"tags":[{"name":"介绍","slug":"介绍","permalink":"https://gitee.com/yunyd/tags/%E4%BB%8B%E7%BB%8D/"}],"author":"llllz."}],"categories":[{"name":"JUC并发编程","slug":"JUC并发编程","permalink":"https://gitee.com/yunyd/categories/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"项目","slug":"项目","permalink":"https://gitee.com/yunyd/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"Linux","slug":"Linux","permalink":"https://gitee.com/yunyd/categories/Linux/"},{"name":"打招呼","slug":"打招呼","permalink":"https://gitee.com/yunyd/categories/%E6%89%93%E6%8B%9B%E5%91%BC/"}],"tags":[{"name":"JUC并发编程","slug":"JUC并发编程","permalink":"https://gitee.com/yunyd/tags/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"项目","slug":"项目","permalink":"https://gitee.com/yunyd/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"Linux","slug":"Linux","permalink":"https://gitee.com/yunyd/tags/Linux/"},{"name":"介绍","slug":"介绍","permalink":"https://gitee.com/yunyd/tags/%E4%BB%8B%E7%BB%8D/"}]}